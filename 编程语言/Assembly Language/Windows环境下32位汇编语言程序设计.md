# Windows环境下32位汇编语言程序设计

1. 在Windows下用任何语言编程都必须遵循Windows的规范，汇编也不例外，也就是说，汇编不再是一种“有特权”的语言。
2. 任何汇编语言都是和操作系统密切相关的，不管是DOS汇编、Win32汇编，还是Linux汇编，都是基于特定的操作系统的。
3. 高级语言在不同的操作系统上看起来都差不多，但作为一种低级语言，不同操作系统上的汇编就是不同的世界。
4. 使用Win32汇编语言是了解操作系统运行细节的最佳方式。

## 第 1 章  背景知识

1. 从微处理器的指令系统来看，有两种分支走向，一种是CISC，即复杂指令系统计算机；一种是RISC，即精简指令系统。  
    精简指令系统采用等长的指令，且指令数较少，通过简化指令可以让计算机的结构更为简单，进而提高运算速度。
2. Win32程序并不直接访问屏幕、打印机和键盘等硬件设备（设备的无关性），Windows虚拟了所有的硬件。  
    只要有硬件的设备驱动程序，这个硬件就可以使用，应用程序并不需要关心硬件的具体型号。
3. 80386处理器有3种工作模式：实模式、保护模式和虚拟86模式。  
    实模式和虚拟86模式是为了和8086处理器兼容而设置的。  
    在实模式下，80386处理器就相当于一个快速的8086处理器。  
    保护模式是80386处理器的主要工作模式。保护模式提供了80386先进的多任务、内存分页管理和优先级保护等机制。  
    虚拟86模式是以任务形式在保护模式上执行的，在80386上可以同时支持由多个真正的80386任务和虚拟86模式构成的任务。  
    实模式下80386不支持优先级，所有的指令相当于工作在特权级（优先级0），所以它可以执行所有特权指令，包括读写控制寄存器CR0等。  
    DOS操作系统运行于实模式下，而Windows操作系统运行于保护模式下。
4. Win32编程相对于DOS编程最大的区别之一就是内存的使用。
5. 80386处理器把4 KB大小的一块内存当做一“页”内存，每页物理内存可以根据“页目录”和“页表”，随意映射到不同的线性地址上。  
    这样，就可以将物理地址不连续的内存的映射连到一起，在线性地址上视为连续。  
    在80386处理器中，除了和CR3寄存器（指定当前页目录的地址）相关的指令使用的是物理地址外，其他所有指令都是用线性地址寻址的。
6. Win32编程中几个很重要的概念：  
    每个应用程序都有自己的4 GB的寻址空间。该空间可存放操作系统、系统DLL和用户DLL的代码，它们之中有各种函数供应用程序调用。再除去其他的一些空间，余下的是应用程序的代码、数据和可以分配的地址空间。  
    不同应用程序的线性地址空间是隔离的。虽然它们在物理内存中同时存在，但在某个程序所属的时间片中，其他应用程序的代码和数据没有被映射到可寻址的线性地址中，所以是不可访问的。从编程的角度看，程序可以使用4 GB的寻址空间，而且这个空间是“私有”的。  
    DLL程序没有自己“私有”的空间。它们总是被映射到其他应用程序的地址空间中，当做其他应用程序的一部分运行。
7. Windows的特权保护和处理器硬件的支持是分不开的。优先级的划分、指令的权限检查和超出权限访问的异常处理等是构成特权保护的基础。
8. 不管中断、异常还是自陷，虽然它们产生的原因不同，但处理过程是类似的，都通过中断向量表里存放的入口地址转移到服务程序，都由CPU自动在堆栈中保护断点地址，最后也都可以用iret指令返回指令被中断的地方。
9. 保护模式下增加了“门”的概念。“门”指向某个优先级高的程序所规定的入口点，所有优先级低的程序调用优先级高的程序只能通过门重定向，进入门所规定的入口点。  
    这样可以避免低级别的程序代码从任意位置进入优先级高的程序的问题。  
    保护模式下的中断和异常等服务程序也要从“门”进入，80386的门分为中断门、自陷门和任务门几种。
10. 有两类指令可以影响保护机制。  
    第一类是改变GDT，LDT，IDT以及控制寄存器等关键寄存器的指令，称为特权指令；  
    第二类是操作I/O端口的指令以及cli和sti等改变中断允许的指令，称为敏感指令。
11. 在Windows下，操作系统运行于0级，应用程序运行于3级。  
    因为Alpha计算机只支持两个优先级，为了便于将应用程序移植到Alpha计算机上，Windows操作系统不使用1级和2级这两个优先级。

## 第 2 章  准备编程环境

1. Win32可执行文件叫做PE文件。  
    PE文件的基本结构和DOS可执行文件有很大的不同。它把程序中的不同部分分成各种节区（Section），其中可以有一个节区是放置各种资源的。
2. 与C源代码类似，asm文件中也可以用include语句包含数据定义和函数声明的头文件，Win32汇编的头文件一般用inc作扩展名。
3. MASM是Microsoft公司推出的汇编编译器。

    ```text
        它的版本从低到高经过了很多次的升级（微软的通病，升级补丁多如牛毛）。
        每次升级除了例行的错误修正外都增加了一些新的功能，以至于到最后高版本和低版本的语法和功能相差很多，向下兼容性也不好。
        要注意的是汇编选项要集中写在源文件名的前面：
            /coff选项是必需的，因为Microsoft的32位的Link只支持将COFF格式的obj文件链接成PE文件，另外所有的导入库等支持文件的格式也全部是COFF格式的。
            其他的选项，如/Cp和/Gz虽然也是必需的，但是由于可以在asm源文件中用伪定义设置，所以一般不在命令行中指定，以免遗漏。
        用Microsoft的产品编写Win32程序，不管是使用VC还是MASM，都必须使用COFF格式。
        用Ml.exe编译的COFF格式的obj文件可以用Link.exe链接成可执行PE文件。
        Microsoft的Link.exe有两个系列的版本：
            用于链接DOS程序的链接器为Segmented Executable Linker；
            可以链接Win32 PE文件的链接器为Incremental Linker 。
            编写普通的Win32可执行文件时，必须用的选项只有/subsystem一个，其他的都可以用默认值。
            使用Link的时候，/subsystem选项必须被指定，一般指定为windows，当编写控制台程序的时候要改为console。
        写dll的时候要用/def指定列表定义文件，同时要指定/dll选项。其他的一些参数如/stub，/section和/base等只在编写特殊用途的程序时才使用。
    ```

4. TASM是Borland公司推出的汇编编译器，也是一种使用很广泛的编译器，与MASM相比，TASM的升级没有这么频繁。  
    由于Windows API区分大小写，所以TASM32的/ml和TLINK32的-c选项必须指定。  
    TLINK32中的-Tpe和-aa选项也必须指定，否则链接出来的就不是Win32可执行文件了。  
    其他的选项如调试信息等则可以根据需要选择使用。
5. TASM和MASM之间的导入库和目标文件等不能通用，程序员无法用Microsoft的链接器来链接TASM产生的obj文件，反之亦然。  
    这是因为TASM的库文件和obj文件一直是OMF格式，与Microsoft使用的COFF格式不兼容。
6. 从工具包的完整性来说，TASM比NASM相对来说要好一点。  
    TASM软件包中包括了32位的资源编译器和链接器，也有一个32位的导入库文件，这样，用户不用添加任何其他软件就可以直接用TASM写出完整的Win32程序。  
    但TASM软件包中也没有Windows数据结构和预定义的头文件，所有资料同样需要用户自己整理。  
    TASM在定义结构的时候，不同的结构中不能有同名的字段，而Windows的数据结构定义出奇的多，结果不同结构中的同名字段要在前面加上一些前缀以示区别，这就会使源代码中的结构定义和参考资料中的结构定义在字面上不符合，使用时还要不停地去看结构中的字段究竟是怎么定义的。这些小缺点使TASM在使用时程序员做的无效工作比有效工作还多。
7. NASM的优点就是学到的语法可以直接用在Linux的汇编中，缺点也是显而易见的，就是免费软件往往缺乏强大的后盾，开发的力度肯定不如大的软件公司。
8. Rc和BRC32在使用中没有必需的选项，不像汇编编译器一样必须使用一些关键的选项。如果编译成功，就会产生以res为扩展名的资源文件，两者生成的资源文件的格式是一样的。
9. 资源文件编写是PE开发的标准步骤，由于不同的语言使用的资源编译器，以及生成的 .res文件格式都是一样的。  
    没有汇编格式的资源文件和C格式的资源文件之分，所以汇编开发包中的资源编译器实际上就是C开发包中的资源编译器。
10. 批处理会执行全部命令将全部源文件编译，包括那些不必重新编译的源文件，而make工具则可根据目标文件上一次编译的时间和所依赖的源文件的更新时间自动判断应当编译哪些源文件，对没有更新过的文件不会处理，这样就可以大大提高程序调试的效率。
11. makefile描述文件的语法：  
    注释是以#号开头一直到行尾的字符，当nmake工具处理到这些字符的时候，它会完全忽略#号及其后面的全部字符。  
    当一行的内容过长的时候，可以用换行符来继续，makefile的换行符是\ 。在使用换行符的时候要注意在“\”后面不能再加上其他字符，包括注释和空格，否则nmake检测到“\”不在一行的最后，就不会把它当成换行符解释，从而出现错误。  
    允许使用简单的宏定义指代源文件及其相关编译信息，可以把宏称为变量。  
    在引用宏时只需在变量前加$符号，但是要注意的是，如果变量名的长度超过一个字符，在引用时就必须加圆括号（）。  
    宏定义最大的好处是可以直接在命令行中用新的宏定义覆盖。  
    在这种使用中要注意两个问题：一是宏名称要区分大小写，ML_FLAG和ml_flag是不一样的；二是定义值中有空格的时候要用双引号引起来（没有空格时可以不用双引号，如ML_FLAG=/c），这使临时使用不同的参数编译文件时可以不必修改makefile。  
    规则可以用两种方法，用方法2的时候，命令可以从第2行开始，第1行的“；”省略，但是这时命令前面必须有一个Tab字符，否则nmake无法区分这究竟是命令还是别的定义。  
    实际上nmake默认将整个描述文件的第一条规则中的目标文件认为是最终文件。
12. 在Win32的环境下，不管是什么语言，全部都是建立在Win32 API的基础上的，而Windows本身就是用C开发的。
