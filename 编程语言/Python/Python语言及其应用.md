# Python语言及其应用（第2版）

## 前言

1. 在大部分情况下，学习计算机语言要比学习人类语言容易，因为不需要记忆那么多模棱两可的东西和例外情况。
2. Python是最一致，也是最清晰的计算机语言之一，在易学性、易用性以及表达力之间取得了很好的平衡。
3. Python的一些特殊功能要优于其他语言中的同类。
4. 不同于其他很多语言，Python把变量当作名称来对待，由此产生了一些重要结果。

## 第 1 章  Python初探

1. 我们一次能记住的东西是有限的。
2. Python的语法非常漂亮，相较于大多数编程语言，记忆难度更小，而且看起来也更自然。
3. Python在数据科学和机器学习领域风头无两。
4. Python是一种优秀的通用高级语言，其设计使之具有非常好的可读性，这可比听起来重要多了。每个计算机程序都只编写一次，但要被许多人多次阅读和修改。
5. 可读性强也使Python更易于学习和记忆，因而更容易书写。与其他流行语言相比，Python的学习曲线比较平缓，能让你更快上手，但同时又不乏深度，可以让你边学习边探索。
6. Python的相对简洁性使你可以编写出比静态语言更短小的等价程序。研究表明，无论使用哪种语言，程序员每天编写的代码行数都差不多，因此，代码量减半可以使生产效率提高一倍。对很多重视这一点的公司来说，Python是一件不算秘密的“秘密武器”。
7. Python3看起来和Python2差别不大，最明显的区别在于print在Python3中是函数，调用的时候需要将参数放入圆括号内。最重要的区别则是Unicode字符的处理方式。

## 第 2 章  数据：类型、值、变量和名称

1. 在底层，计算机中的一切都只是位序列而已。
2. 在Python中，一切皆是对象。  
    对象是至少包含以下内容的数据块：

    ```text
    * 类型，定义了可以执行什么操作；
    * 唯一的ID，用于区分其他对象；
    * 与类型一致的值；
    * 引用计数，用于跟踪该对象的使用频率；
    ```

3. Python是强类型语言，这意味着对象的类型是无法改变的，即便其值是可变的。  
    Python变量是没有类型的，它可以指向任何类型的对象。  
    Python变量是对象的引用。
4. 查看Python保留字：

    ```python
    * help("keywords")
    * import keyword
      keyword.kwlist
    ```

## 第 3 章  数字

1. 在Python中，布尔型的有效值只有True和False  
    函数bool()能将任意的Python数据类型转换为布尔值。  
    bool()函数可以接受任何值作为参数并返回等价的布尔值。  
    非零的数被视为True；值为0的数被视为False
2. 整数就是既没有分数也没有小数点的数字。
    可以使用下划线(_)作为数位分隔符；  
    截断式整数除法(//)会返回整数，丢弃小数部分；  
    如果除数为0，则任何一种除法运算都会产生Python异常；  
    在Python3中，int类型可以是任意大小；
3. 0b 或 0B 表示二进制  
    0o 或 0O 表示八进制  
    0x 或 0X 表示十六进制

## 第 4 章  if语句

1. Python 使用空白字符来定义程序结构的做法并不常见。
2. Python 使用 # 字符标记注释，从 # 开始到当前行结束的部分都属于注释。  
    Python 没有多行注释。你需要明确地在每一行注释前加上 #
3. 可以使用续行字符 \ （反斜线）表明后续内容仍在同一行，只需要把 \ 放在行尾。
4. if语句在Python中不需要圆括号。
5. 在Python中，缩进决定了 if 代码段和 else 代码段如何配对。
6. Python允许执行连续比较： 5 < x < 10
7. 对于字典，in 查看的是键而不是值。
8. 海象运算符（:=）也称赋值表达式，是Python3.8新引入的，可在表达式内部为变量赋值。

## 第 5 章  字符串

1. 字符串就是字符序列。  
    Python中的字符串是不可变的；  
    单引号或双引号都可以创建字符串，三引号可以创建多行字符串；  
    可以在双引号字符串中加入单引号，或是在单引号字符串中加入双引号；
2. Python 特殊类型字符串：

    ```text
    f或F：格式化字符串  
    r或R：原始字符串            其中的转义序列不会被解释  
    u或U：Unicode字符串  
    b或B：类型 bytes 的实例
    ```

3. 如果三引号中有不止一行代码，那么换行符就会被保留在字符串内。如果有前导空格或尾随空格，则换行符同样会被保留。  
    疑问：是换行符同样会被保留吗，不应该是前导空格或尾随空格被保留吗？
4. 当你对非字符串对象调用 print() 以及格式化字符串时，Python会在内部使用 str() 函数。
5. 原始字符串不会去掉任何真实的（非'\n'）换行符。
6. 在拼接字符串时，Python不会替你添加空格，所以先前的一些例子需要明确添加空格。  
    Python会在 print() 函数的参数之间添加空格并在行尾加上换行符。
7. 可以使用 * 运算符重复某个字符串。
8. 可以使用 [] 获取字符，索引越界会报错。
9. 可以使用分片从字符串中提取子串。  
    [start : end : step]  
    切片包含start，但不包含end  
    步长值为负数可以实现反向提取分片  
    字符串没有reverse()函数，可以使用切片实现这个功能：str[ : : -1]  
    比字符串起始位置还靠前的偏移被视为 0 ，超出结束位置的偏移被视为 -1  （此处指结束位置，实际不是-1）
10. 字符串格式化：

    ```text
    旧样式：format_str % data
        字符串内 % 的数量要和数据项数量相同
        多个数据项时必须使用元组形式  
        可以使用特定的格式说明符
    新样式：format_str.format(data)
        参数顺序和占位符 {} 保持一致
        可以按位置或名称指定参数
        可以使用字典指定参数
        可以使用特定的格式说明符
    最新样式： f'format_str'    Python3.6以上
        {} 内可以使用表达式和方法调用
        Python3.8 加入了一种快捷写法方便调试
    ```

11. 字符串常用函数：

    ```python
    len()           获取长度            len(str)
    split()         分割为列表          str.split(sep=None, maxsplit=- 1)       sep 默认为任意空白字符序列（换行符、空格和制表符）
    join()          合并字符串          str.join(iterable)
    replace()       替换子串            str.replace(old, new[, count])          count 默认替换所有
    strip()         删除两侧字符        str.strip([chars])                      chars 默认移除空白符
    lstrip()        删除左侧字符        str.lstrip([chars])
    rstrip()        删除右侧字符        str.rstrip([chars])
    startswith()    以指定字符串开头    str.startswith(prefix[, start[, end]])
    endswith()      以指定字符串结尾    str.endswith(suffix[, start[, end]])
    find() / rfind()    查找子字符串索引    str.find(sub[, start[, end]])       未找到返回 -1
    index() / rindex()  同 find()           str.index(sub[, start[, end]])      未找到抛出异常
    count()         统计出现次数        str.count(sub[, start[, end]])
    isalnum()       都是字母或数字      str.isalnum()
    capitalize()    首字母大写          str.capitalize()
    title()         每个单词首字母大写  str.title()
    upper()         全部转为大写        str.upper()
    lower()         全部转为小写        str.lower()
    swapcase()      大小写转换          str.swapcase()
    center()        居中对齐            str.center(width[, fillchar])
    ljust()         左对齐              str.ljust(width[, fillchar])
    rjust()         右对齐              str.rjust(width[, fillchar])
    ```

## 第 6 章  while循环和for循环

1. 如果循环正常结束而没有执行break语句，则会执行可选的else子句。
2. Python频繁地用到迭代器，这是有充分理由的。迭代器允许你遍历数据结构，无须知道其具体大小和实现。你甚至可以一边创建一边迭代数据，借此处理无法一次性全部读入计算机内存的数据流。
3. range()函数可用于生成数字序列：range(start, stop, step=1)

## 第 7 章  元组和列表

1. 元组和列表可以包含不同类型的元素，但一般情况下，各个元素的类型相同。每个元素可以是任意的Python对象。
2. 元组是 immutable（不可变的），列表是 mutable （可变的）。
3. 元组和列表操作：  
    使用 + 拼接；  
    使用 * 复制元素；  
    使用比较运算符比较大小；  
    使用 for...in 迭代元素；
4. 创建元组：

    ```python
    * empty_tuple = ()
    * one_ele = 'one',             #单个元素时逗号是必须的
      one_ele = ('one',)
    * eles_tuple = 'one', 'two', 'three'
      eles_tuple = ('one', 'two', 'three')
    * tuple(list)
    ```

5. 元组解包：

    ```python
    * a, b, c = eles_tuple
    * a, b = b, a                   #交换两个变量的值
    ```

6. 元组的优点：  
    元组占用空间少；  
    不会误破坏元组项；  
    可作为字典键；  
    具名元组可替代简单对象；
7. 列表元素的值可重复，列表对象会保持其成员的顺序。
8. 创建列表：

    ```python
    * empty_list = []
      empty_list = list()
    * eles_list = ['one', 'two', 'three']
    * eles_list = list(iterable)
    * eles_list = [expression for item in iterable]
    ```

9. 可以使用 [offset] 获取列表元素，索引越界会报错。
10. 可以使用切片获取子列表： [start : end : step]  
11. 列表有reverse()函数：list.reverse() ，但也可以使用切片实现这个功能：list[ : : -1]
12. 可以使用索引修改列表项，使用切片修改子列表：  
    list[i] = e  
    list[start : end] = iterable
13. 可以使用copy()、list()或切片复制列表（浅复制）。  
    deepcopy()能够处理深嵌套列表、字典以及其他对象（深复制）。
14. 使用zip()函数可以并行迭代多个序列，当最短的序列被处理完后，zip()就会停止。
15. zip()返回的可迭代序列可转换为list或dict：  
    转换为列表：list(zip(iterable, iterable))  
    转换为字典：dict(zip(iterable, iterable))
16. 列表常用函数：

    ```python
    del                 删除元素                del list[i]
    in                  包含测试                e in list
    len()               获取长度                len(list)
    append()            添加元素                list.append(e)
    insert()            插入元素                list.insert(i, e)           #在 i 索引位置插入 e 。0 会在起始位置插入，大于 len 会在尾部添加
    extend()            扩展列表                list.extend(iterable)
    remove()            删除第一个匹配项        list.remove(e)
    pop()               删除并返回列表项        list.pop(i)                 # i 默认为 -1，删除最后一项
    clear()             清空列表                list.clear()
    index()             查找索引                list.index(e)               # 返回第一个匹配项的索引，没有找到抛出异常
    count()             统计出现次数            list.count(e)
    sort()              就地排序                sort(list, key=None, reverse=False)
    sorted()            返回排序副本            list.sorted(key=None, reverse=False)
    ```

## 第 8 章  字典和集合

1. 字典（也称关联数组或哈希表）的键可以是任意的不可变类型。
2. 创建字典：

    ```python
    * empty_dict = {}
      empty_dict = dict()
    * eles_dict = {'a':1, 'b':2, 'c':3}
      eles_dict = dict(a=1, b=2, c=3)
    * eles_dict = dict([['a',1], ['b',2], ['c',3]])         # dict()可以将双值序列转换为字典
    * eles_dict = {key : value for item in iterable}
    ```

3. 字典的键必须是唯一的。在给字典项赋值时，不存在的键会添加新值，已存在的键将用新值替代旧值。
4. 使用 d[key] 获取字典项，key不存在时会抛出异常。使用 d.get(key[, default]) 获取字典项，default默认为None
5. 从Python3.5开始，可以使用 `{**a,**b}` 合并字典（独角闪光兽）（浅复制合并）。
6. 可以使用 == 和 != 比较字典。其他比较运算符不适用于字典。
7. 字典常用函数：

    ```python
    del                 删除元素                del d[key]
    len()               获取长度                len(d)
    keys()              获取所有键              d.keys()                # 返回可迭代视图，可以使用 list(d.keys()) 转换为列表
    values()            获取所有值              d.values()
    items()             获取所有项              d.items()
    update()            合并字典                d.update([other])
    pop()               移除并返回项            d.pop(key[, default])   # default 未给出且 key 不存在于字典中，则会引发异常
    clear()             移除所有元素            d.clear()
    copy()              返回原字典的浅拷贝      d.copy()
    deepcopy()          深拷贝                  copy.deepcopy(d)        # deepcopy() 是 copy 模块的函数
    ```

8. 集合是无序的。
9. 创建集合：

    ```python
    * empty_set = set()         # {} 创建的是空字典
    * eles_set = {'a', 'b', 'c'}
    * eles_set = set(iterable)
    * eles_set = {value for item in iterable}
    ```

10. 集合操作：

    ```text
    * 交集：    a & b
                a.intersection(b)
    * 并集：    a | b
                a.union(b)
    * 差集：    a - b
                a.difference(b)
    * 异或集：  a ^ b
                a.symmetric_difference(b)
    * 子集：    a <= b
                a.issubset(b)
    * 真子集：  a < b
    * 超集：    a >= b
                a.issuperset(b)
    * 真超集：  a > b
    ```

11. 可以使用 frozenset([iterable]) 创建不可变集合。
12. 字典和集合操作：  
    使用 for...in 迭代元素；  
    使用 in 测试是否包含；
13. 集合常用函数：

    ```python
    len()               获取长度                len(s)
    add()               添加元素                s.add(elem)
    remove()            移除元素                s.remove(elem)
    ```

## 第 9 章  函数

1. 代码重用的第一步是使用函数。
2. 函数是独立于其他代码的具名代码段。它可以接受任意数量和类型的输入参数，返回任意数量和类型的输出结果。
3. 函数名称只能包含大写字母、小写字母、数字、下划线，且必须以字母或下划线开头。
4. 定义函数：  
    Python 要求使用 pass 语句表明该函数不作任何操作；

    ```python
        def f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2):
            ' / 和 * 是可选的。这些符号表明形参如何把参数值传递给函数：位置、位置或关键字、关键字。 '
            pass
    ```

5. Python 实参到形参的传递方式跟 Java 一致，采用按值传递方式。
6. 如果函数没有明确使用 return ，则返回 None （判断方式： obj is None）。
7. 函数调用时，关键字参数必须跟在位置参数后面。  
    所有传递的关键字参数都必须匹配一个函数接受的参数，关键字参数的顺序并不重要，这也包括必选参数。  
    不能对同一个参数多次赋值。
8. 为参数指定默认值是非常有用的方式。  
    调用函数时，可以使用比定义时更少的参数。  
    默认值在 定义 作用域里的函数定义中求值。  
    重要警告： 默认值只计算一次。默认值为列表、字典或类实例等可变对象时，会产生与该规则不同的结果。
9. `*args` 形参接收一个元组，该元组包含形参列表之外的位置参数。  
    `**kwargs` 形参接收一个字典，该字典包含与函数中已定义形参对应之外的所有关键字参数。  
    `**kwargs` 形参可以与 `*args` 形参组合使用（`*args` 必须在 `**kwargs` 前面）。
10. 使用 help(function_name) 或 `f.__doc__` 可以查看函数的文档字符串。
11. 函数是Python的“头等公民”，你可以将其赋值给变量，用作其他函数的参数和返回值。
12. 在Python中，圆括号意味着调用该函数。如果不加圆括号，则Python会将函数视为与其他对象一样。这是因为，就像Python中的其他东西一样，函数也是对象。
13. 可以使用函数作为列表、元组、集合以及字典的元素。由于函数是不可变的，因此也可以将其用作字典的键。
14. 可以在一个函数的内部定义另一个函数（内部函数）。  
    内部函数可以作为闭包，闭包是一个动态创建的函数，能够记住创建时所在的环境。
15. lambda函数:  
    lambda函数是一个可表达为单语句形式的匿名函数。你可以用它来代替普通的微型函数。  
    lambda可以有0个或多个以逗号分隔的参数，然后是冒号(:)，接着是函数定义。  
    通常，使用正式定义的函数要比lambda清晰的多，但是当需要定义大量微型函数并且不得不记住这些函数名称时，lambda就能帮上大忙了。尤其是在图形用户界面中使用lambda定义回调函数。
16. 生成器：  
    生成器是一个Python序列生成对象。有了它，你就可以对可能会很长的序列进行迭代，无须一次性在内存中创建并保存整个序列。  
    生成器经常作为迭代器的数据源。  
    每次迭代生成器，都会记录上次被调用时所在的位置并返回下一个值。这一点和普通函数不同，后者并不会记录之前的调用，总是以同样的状态从函数的第一行代码开始执行。  
    生成器通过yield语句而非return语句返回值。  
    生成器只能运行一次。列表、集合、字符串和字典存在于内存之中，而生成器是动态生成值，迭代器会将其一次一个送出。由于生成器并不会记忆这些值，因此你无法重启或备份生成器。  
    生成器推导式：`(value for item in iterable)`  
    Python3.3 加入了 yield from 表达式，此表达式可以让一个生成器把部分工作交给另一个生成器。
17. 装饰器是一种函数，接受一个函数作为输入并会返回另一个函数。  
    可以以注解方式为函数添加装饰器。位置最接近函数的装饰器优先级最高，然后依次递减。
18. 主程序部分定义了全局(global)名称空间，在其中定义的变量就是全局变量。  
    要想在函数中访问全局变量而非局部变量，需要明确使用global关键字。
19. 以双下划线（`__`）起止的名称是保留给Python内部使用的，不要将它们与你自己的变量一起使用。  

    ```python
    __name__        函数名称（主程序的名称为__main__）
    __doc__         文档字符串
    ```

20. Python3.5 加入了关键字 async 和 await ，用于定义和运行异步函数。  
    如果在函数的 def 行之前看到async ，则该函数为异步函数。  
    如果在函数调用之前看到await ，则该函数为异步调用。
21. 好的做法是在可能发生异常的任何地方加入异常处理，让用户知道发生了什么。  
    你也许无法修复问题，但至少能够注意到出现了状况并有条不紊地终止程序。  
    如果异常发生在函数中，并且没有被捕获到，则会向上传播，直到被某个调用函数相匹配的处理程序捕获。  
    如果你没有提供自己的异常处理程序，那么Python就会打印出错误消息和一些与错误位置相关的信息，然后终止该程序。
22. 代码块try中的代码会被执行。如果出现错误，就会产生异常并运行代码块except中的代码。如果没有错误，则会跳过代码块except  
    无参数的except可以捕获任意类型的异常。  
    具体的异常处理程序数量没有限制。

## 第 10 章  对象和类

1. 唯一需要查看对象内部的时候就是当你想创建自己的对象或修改现有对象的行为时。
2. 对象是包含数据（变量，称为特性）和代码（函数，称为方法）的自定义数据结构。  
    特性是类或对象中的变量。  
    在创建对象或类的期间和之后，可以为其分配特性。  
    特性可以是其他任何对象。  
    当你听到“特性”这个词时，通常指的是对象特性。另外还有类特性。  
    方法是类或对象中的函数。
3. 如果想在创建对象时分配对象特性，那么需要使用特殊的Python对象初始化方法`__init__`  
    当你在类定义中编写`__init__`时，第一个参数应该是self 。尽管self在Python中并非保留字，但这是一种惯常用法。  
    `__init__()`并不是其他语言中的“构造函数”，Python已经替你把对象构造好了，不妨将其视为初始化函数。
4. 可以从单个类中生成多个对象。但是要记住，因为Python是以对象的形式实现数据的，所以类本身也是对象。然而，程序中只能有一个类对象。
5. 继承：  
    可以使用issubclass()检查一个类是否从另一个类派生而来。  
    包括`__init__()`在内的任何方法都可以被子类覆盖。子类也可以添加父类中没有的方法。  
    如果在子类中定义了`__init__()`方法，则父类中的`__init__()`会被替换，不再被自动调用，因此，需要显式地调用它。  
    可以使用super()调用父类的方法。  
    如果类引用了不属于自己的方法或特性，那么Python就会在所有父类中查找。
6. Python支持多重继承。  
    Python继承的特性或方法取决于方法解析顺序，解析顺序按广度优先进行。  
    每个Python类都有一个特殊方法mro()，可以返回一个类列表，用于查找该类对象的方法或特性。还有一个类似的特性__mro__，是由这些类组成的元组。

    ```text
        多重继承的查找顺序：
            1. 对象自身；
            2. 对象的类；
            3. 对象的第一个父类；
            4. 对象的第二个父类；
            5. 类的祖父类；
    ```

7. 可以在类定义中加入一个额外的父类，但仅作为辅助之用。  
    这种父类有时被称为mixin类，其用法包括执行一些“辅助”任务。
8. 在Python中，对象特性和方法通常是公开的。  
    实际上，在Python中没有任何东西能强制隐藏数据 --- 它是完全基于约定的。  
    对于不该对类定义之外可见的特性，Python有自己的命名规则：以两个下划线（`__`）起始。  
    这种命名规则并不能使特性完全私有，但Python确实会对特性名称进行重整，使其不太可能被外部代码发现。
9. Python中并不存在“私有”实例变量。  
    但是，大多数Python代码都遵循这样一个约定：带有一个下划线的名称应该被当作是API的非公有部分(无论它是函数、方法或是数据成员)。  
    这应当被视为一个实现细节，可能不经通知即加以改变。
10. 对于特性隐私，Python式的解决方案是使用属性。

    ```python
    有两种实现方法：
        * name = property(get_name, set_name)   
        * @property & @name.setter 
    ```

    属性也可以返回计算值。  
    如果没有为特性指定setter属性，就无法从外部设置该特性。这对于只读特性非常方便。
11. 可以为类设置各种特性，这些特性会被类的子对象继承。  
    改变子对象的特性并不会影响类的特性；  
    改变类的特性也不会影响已有的子对象；  
    但是会影响新对象。
12. 有些方法属于类本身，有些方法属于该类的对象，有些则两者都不属于。  
    如果没有前置装饰器，就是实例方法，其第一个参数应该是self，引用对象本身；  
    如果有前置装饰器@classmethod，就是类方法，其第一个参数应该是cls，引用类本身；  
    如果有前置装饰器@staticmethod，就是静态方法，其第一个参数不能是对象或类；
13. 类方法影响的是整个类。对类做出任何改动都会影响该类所有的对象。
14. Python松散地实现了多态，可以根据方法的名称和参数将相同的操作应用于不同的对象，不管他们的类是什么。
15. print()、str()以及字符串格式化工具使用`__str__()`打印对象。交互式解释器使用`__repr__()`方法回显变量。
16. 何时使用对象或其他东西：

    ```text
    * 当需要行为（方法）相似，但内部状态（特性）不同的多个实例时，对象最有用。
    * 类支持继承，模块则不支持。
    * 如果只想二选一，那么模块也许是最合适的。一个Python模块无论在程序中被引用了多少次，都只装载一个副本。
    * 如果你有一些包含多个值的变量，并且可以作为参数传递给多个函数，那么将其定义为类可能会更好。
    * 使用最简单的方法解决问题。字典、列表或元组要比模块更简单、更小巧且更快速，而模块往往又比类简单。
    * 避免过度设计数据结构。元组比对象好（也可以尝试具名元组）。简单的字段优先于 getter/setter 函数…… 内建数据类型是你的好朋友。多用数字、字符串、元组、列表、集合和字典。多看看容器数据类型，尤其是双端队列。    —— Guido van Rossum
    ```

17. 具名元组是元组的子类，可以按名称(.name)或位置(`[offset]`)访问值。具名元组的优点：  
    外观和行为都像一个不可变对象；（具名元组是不可变的）  
    比对象更节省空间和时间；  
    可以使用点号记法代替字典式的中括号记法访问特性；  
    可以将其用作字典键。
18. Python3.7 引入了数据类。  
    除了需要 @dataclass装饰器，定义类特性的时候要使用形如 name: type 或 name: type=val 的变量注解。  
    其中，type可以是包括类在内的任意Python对象类型，不仅限于内建类型。  
    在创建数据类对象时，要按照类中指定的顺序提供参数，或是使用具名参数（可以采用任意顺序）。
19. 具名元组和数据类是标准库中的替代方案，当主要想创建数据集合时，使用它们可能会更简单。  
    "The One Python Library Everyone Needs" 一文中推荐了第三方包 attrs

## 第 11 章  模块、包和赠品

1. 模块就是包含任意Python代码的文件。
2. import语句最简单的用法是import module ， 其中 module 是另一个Python文件的名称（不包含 .py 扩展名）。
3. 在import之后，模块中的一切都可使用，只需在其名称前加上模块名（或者别名）即可。通过使用模块名称限定模块内容，避免了命名冲突的问题。
4. 包就是含有 .py 文件的子目录，其中可以有多个目录层级。  
    如果Python版本低于3.3，则还需要在目录中添加一个名为`__init__.py`的文件，才能使其成为Python包。这个文件可以为空，但3.3之前的Python版本需要它，这样才能将目录作为包。
5. 模块搜索路径：  
    使用sys.path可以查看Python解释器搜索路径的列表，Python会依次在其中查找要导入的模块，优先使用最先匹配到的项。  
    可以在自己的代码中修改搜索路径。  
    Python支持相对导入和绝对导入。
6. 一个Python模块无论在程序中被引用了多少次，都只装载一个副本。
7. Python的著名主张之一是“自备电池”——一个庞大的标准模块库，可用于完成大量实用任务。
8. 使用 setdefault() 和 defaultdict() 处理缺失的键：  
    试图访问字典中不存在的键会产生异常。使用字典函数 get() 返回默认值可以避免异常。  
    setdefault() 函数与 get() 函数类似，但会在键缺失时添加字典项。  
    defaultdict() 的操作类似，但是会在创建字典时为每个新键指定默认值。  
    defaultdict() 的参数是一个函数，其返回值会被赋给缺失的键。  
    可以使用函数 int()、list() 和 dict() 返回默认的空值：int() 返回 0，list() 返回空列表 ([])，dict() 返回空字典 ({})  
    如果忽略该函数参数，则新键的初始值会被设置为 None
9. 使用 Counter() 计数：  
    可以使用 Counter() 进行计数，还可以使用运算符对计数器进行组合。  
    +（和）、-（差）、&（交）、|（并）
10. 使用 OrderedDict() 按键排序：  
    OrderedDict() 能记住键被添加时的顺序并以同样的顺序从迭代器中将其返回。  
    从Python3.7开始，字典会保留键被添加时的顺序。OrderedDict 对早期的Python版本很有用，因为其字典顺序是不可预测的。
11. 栈 + 队列 = 双端队列：  
    deque 是一种双端队列，兼具栈和队列的功能。
12. 使用 itertools 迭代代码结构：  
    itertools包含特殊用途的迭代器函数，尤其是一些用于组合和排列的函数，在需要时它们可以节省大量时间。  
    chain() 会遍历其参数，将其视为单个可迭代对象。  
    cycle() 是一个无穷迭代器，会循环遍历其参数。  
    accumulate() 会计算累计值。默认情况下，其计算的是累加和。可以提供一个函数作为第二个参数，以此代替默认的加法。
13. 使用 pprint() 会尝试为其元素提供更好的可读性。
14. 获得随机数：  
    random.choice() 函数从指定的序列（列表、元组、字典、字符串）参数中返回一个值。  
    random.sample() 函数一次性获取多个值。  
    要想获取任意区间内的整数，可以将 choice() 或 sample() 配合 range() 使用，也可以使用 randint() 或 randrange()  
    random() 函数可以获取 0.0 和 1.0 之间的随机实数（浮点数）。

## 第 12 章  数据处理

1. 数据格式粗略地分为两类：文本和二进制。  
    Python字符串用于文本数据。
2. Unicode字符串：

    ```text
    * Python3的字符串是Unicode字符序列，而非字节数组。这是Python2到Python3最大的变化。
    * 如果知道某个字符的Unicode ID或名称，就可以在Python字符串中使用该字符。
        \u 后面可以跟上4个十六进制数字，指定Unicode基本多语言平面中的某个字符；
        对于更高平面内的字符，需要使用更多的位数。可以使用Python转义序列 \U （大写） 后面跟上 8 个十六进制数字，高位必须写作 0
        可以使用 \N{name} 按照标准名称指定任意字符。
    * Python能处理所有的Unicode字符，唯一可能碰到的问题是用于显示文本的字体。
        几乎没有哪种字体能够涵盖所有的Unicode字符，当缺失对应字符时，会以占位符的形式显示。
    * Unicode Character Name Index 页面列出了字符的名称。
        字符名称经过了重新格式化，以使其能够更美观地排列显示。要想获得真实的Unicode名称，只需删除逗号，将其之后的内容移到最前面即可。
    * 字符串函数len()统计的是Unicode字符数，而非字节数。
    * 如果知道Unicode字符的编码值，就可以使用标准函数ord()和chr()在整数编码值和单个Unicode字符之间快速转换。
    * 在进行正常的字符串处理时，不用关心Python是如何存储每个Unicode字符的。
        但是，当你与外部交换数据时，需要知道两件事：将字符串编码为字节；将字节解码为字符串。
    * Python3.4引入了另一种转换Unicode字符的方法：使用HTML字符实体。
    ```

3. UTF-8是Python、Linux和HTML的标准文本编码。这种编码速度快、完备且效果良好。  
    UTF-8 是一种变长编码。可以将任何文本编码为UTF-8，尽可能使用UTF-8编码。  
    如果你是通过从别的文本源复制粘贴的方式来创建Python字符串，那么一定要确保文本源使用的是UTF-8编码。将其他编码的文本复制进python字符串的错误屡见不鲜，这会造成后续的无效字节序列异常。  
    从外部数据源获得的文本都会被编码为字节序列形式。只要知道采用的是哪种编码，就可以倒推出Unicode字符串。
4. 字符串相关函数：

    ```python
    * str.encode(encoding='utf-8', errors='strict')       将字符串编码为字节序列
    * bytes.decode(encoding='utf-8', errors='strict')     将字节序列解码为Unicode字符串
    * unicodedata.normalize(form, unistr)                 返回 Unicode字符串的规范化形式
    * unicodedata.lookup(name)                            接受字符名称（不区分大小写），返回对应的Unicode字符
    * unicodedata.name(chr[, default])                    接受Unicode字符，返回对应的字符名称（大写形式）
    ```

5. 正则表达式模式匹配由标准模块re提供：

    ```text
    * 因为这是一个常见的Python陷阱，所以我再重申一次：match()仅匹配源字符串开头的模式。search()匹配源字符串中任意位置的模式。
    * 这里的大部分正则表达式使用的是ASCII字符，但是Python的字符串函数（包括正则表达式）能够处理任意的Python字符串和Unicode字符。
        正则表达式并不局限于匹配ASCII字符。\d 能够匹配Unicode中的任何数字字符，而不仅仅是ASCII字符 '0' 到 '9'
    * 字符 ^ 和 $ 被称为锚点： ^ 将搜索锚定在字符串起始，$ 将搜索锚定在字符串结尾。
    * Python有一些特殊的转义序列。例如，\b 代表退格，但在正则表达式中，\b 代表单词边界。
        为了避免这种歧义，在定义正则表达式字符串时，可以使用Python的原始字符串。只要把 r 字符放在正则表达式字符串之前，Python就会禁用转义序列。
    * 在使用 match() 或 search() 时，结果对象 m 中的所有匹配以 m.group() 返回。
        如果将模式放入圆括号内，对应的匹配会被保存在单独的分组中，由其组成的元组可以通过 m.groups() 获得。
    ```

6. 正则表达式相关函数：

    ```python
    * re.match(pattern, string, flags=0)                只在字符串的开头检查匹配项
    * re.search(pattern, string, flags=0)               检查字符串中的任何位置是否匹配
    * re.fullmatch(pattern, string, flags=0)            检查整个字符串是否匹配
    * re.findall(pattern, string, flags=0)              返回 pattern 在 string 中的所有非重叠匹配，以字符串列表或字符串元组列表的形式
    * re.split(pattern, string, maxsplit=0, flags=0)    用 pattern 分开 string
    * re.sub(pattern, repl, string, count=0, flags=0)   返回通过使用 repl 替换在 string 最左边非重叠出现的 pattern 而获得的字符串
    ```

7. Python3引入了两种类型的8位整数序列：  
    * bytes是不可变的，类似于字节元组；  
    * bytearray是可变的，类似于字节列表。
8. 标准库有一个struct模块，可以处理类似于C和C++中结构体形式的数据。通过struct，你可以在二进制数据和Python数据结构之间任意转换。
9. 二进制数据处理需要注意大小端和格式说明符。
10. 标准模块binascii提供了在二进制数据和各种字符串描述（十六进制、BASE64、Unicode等）之间的转换的函数。
11. Python提供了类似于C语言中的位运算符。

## 第 13 章  日历和时钟

1. Python标准库中有很多日期和时间模块，包括datetime、time、calendar、dateutil等。各个模块功能之间有部分重叠，多少会造成些困惑。
2. 标准模块datetime可用于处理日期和时间。该模块定义了4个主要的对象类：date、time、datetime、timedelta  
    date的取值范围从date.min(00010101)到date.max(99991231)。因此，不能将其用于历史或天文计算。
3. ISO 8601是表示日期和时间的国际标准。对于程序中的日期以及按照日期保存数据的文件名称，我通常都会选择这种格式。
4. 如果没有提供所有参数，则time会假定缺失的参数均为0  
    能存储和检索微秒并不意味着你可以将计算机中的时间精确到微秒。  
    亚秒级测量的准确性取决于硬件和操作系统中的诸多因素。
5. 可以使用combine()将date对象和time对象合并成datetime对象；也可以使用date()方法和time()方法从datetime对象中提取date和time
6. 令人困惑的是，Python有一个带有time对象的datetime模块，以及一个单独的time模块。  
    time模块还有一个函数叫做time()；  
    localtime()提供了系统时区时间；  
    gmtime()提供了UTC时间（协调世界时）；  
    mktime()将struct_time对象转换为纪元秒；  
    struct_time对象只保留到秒；
7. 表示绝对时间的一种方法是计算从某个时间起点开始的秒数。  
    Unix时间使用自1970年1月1日0点开始的秒数。  
    这个值通常称为纪元（epoch），它是在系统之间交换日期和时间的最简单方法。  
    纪元值是与不同系统交换日期和时间时的最小公分母。
8. 尽可能使用UTC代替时区。UTC是绝对时间，与时区无关。  
    如果你有服务器，就将其时间设置为UTC，不要使用当地时间。  
    尽可能避免使用夏令时。
9. 可以使用strftime()将日期和时间转换为字符串。  
    可以使用strptime()将字符串转换为日期或时间。  
    datetime对象、date对象和time对象将strftime()作为方法提供，time模块将其作为函数提供。

## 第 14 章  文件和目录

1. Python的文件操作在很大程度上是以Unix操作系统为模型。
2. 创建或打开文件：

    ```python
    *   fileobj = open(filename, mode)
            mode的第一个字符：
                r       读取
                w       写入：不存在则创建，存在则覆盖
                x       不存在时写入，存在抛出异常
                a       存在时追加，不存在抛出异常
            mode的第二个字符：
                t       文本文件，默认值
                b       二进制文件

    *   with open(filename, mode) as fout:
    ```

3. 可以使用带 file 参数的 print 函数写入文件内容。  
    如果没有指定 file 参数，则 print 会向标准输出写入，后者通常是你的终端。
4. 可以使用不带参数的 read() 函数一次读入整个文件，在读入大文件时要小心，1GB的文件会占用相同大小的内存。  
    可以设置最大字符数以限制 read() 函数一次返回的字符数量。  
    读取完文件所有内容之后，再次调用 read() 会返回空串（''），在 if 判断中为 False  
    **读取文件最简单的方法是使用迭代器，每次返回一行。**
5. 需要关闭文件，确保所有写入操作顺利完成并释放内存。  
    如果忘记关闭打开过的文件，那么Python会在该文件不再被引用时将其关闭。  
    这意味着如果在函数内打开了文件，但没有关闭，那么当函数结束时，该文件会被自动关闭。  
    如果是在长时间运行的函数或主程序部分打开的文件，则应该主动关闭，强制完成未执行的写操作。
6. Python的上下文管理器可以帮助清理资源。  
    当上下文管理器中的代码运行结束后（正常结果或是引发异常），文件会被自动关闭。
7. 读写文件的另一种方法是使用mmap模块进行内存映射。  
    这使得文件内容看起来就像是内存中的 bytearray
8. 在指定名称时，Python使用斜线（'/'）作为路径分隔符。  
    在Windows中，可以使用反斜线（'\'）  
    但是反斜线在Python中用作转义字符，所以要么使用连续两个反斜线，要么使用Python的原始字符串。
9. Python3.4加入了 pathlib 模块，用于代替 os.path 模块。  
    pathlib 中引入了 Path 对象，以从更高的层面处理路径，而不再将其简单地视为字符串。
10. 可以使用 io.BytesIO 和 io.StringIO 将数据包装成类文件对象。
11. 文件目录相关函数：

    ```python
    * open(file, mode='r')              打开文件
    * close()                           关闭文件
    * read(size=- 1, /)                 读取
    * write()                           写入
    * readline()                        读取一行
    * readlines()                       读取并返回多行的列表
    * tell()                            查看当前偏移位置
    * seek(offset, whence=SEEK_SET, /)  跳转到指定偏移位置，主要用于二进制文件
        SEEK_SET 或 0                       流的开头（默认值）；offset 应为零或正值
        SEEK_CUR or 1                       当前流位置；offset 可以为负值
        SEEK_END or 2                       流的末尾；offset 通常为负值
    * os.path模块：
        exists()                        检查文件是否存在
        isfile()                        检查是否为文件
        isdir()                         检查是否为目录
        islink()                        检查是否为符号链接
        isabs()                         检查是否为绝对路径
        abspath()                       获取绝对路径
        realpath()                      获取符号链接路径名
        join()                          构建路径名称
    * os模块：
        link()                          创建硬链接
        symlink()                       创建符号链接
        chmod()                         改变文件权限
        chown()                         改变文件所有者
        remove()                        删除文件
        mkdir()                         创建目录
        rmdir()                         删除目录
        listdir()                       列出目录
        chdir()                         改变当前目录
    * shutil模块：
        copy()                          复制文件
        move()                          移动文件
        rename()                        重命名
    * glob模块：
        glob()                          查找匹配的文件和目录
            *                               匹配任意多个字符
            ?                               匹配单个字符
            [abc]                           匹配 a 或 b 或 c
            [!abc]                          匹配除a、b、c之外的任意字符
    ```

## 第 15 章  进程和并发

1. 当你运行程序时，操作系统会创建相应的进程。  
    进程要使用系统资源（CPU、内存和磁盘空间）和操作系统内核数据结构（文件和网络连接、用量统计等）。  
    进程之间相互隔离，无法看到彼此的操作，也干涉不了对方。
2. 可以使用标准库的subprocess模块在Python程序中启动和停止其他程序。
3. 可以将Python函数作为单独进程运行，甚至可以使用multiprocessing模块创建多个独立进程。
4. 第三方包psutil也可以提供Linux、Unix、macOS和Windows的系统和进程信息。
5. 诀窍在于让它们彼此协同工作。任何共享的控制或状态都将意味着瓶颈。  
    一个更大的诀窍是故障处理，因为并发计算的难度高于常规计算。更多的地方可能会出错，端到端成功的概率更低。
6. 一般而言，队列用来传递消息，消息可以是任意类型的信息。
7. 线程运行在进程内，能够访问进程的一切资源。  
    multiprocessing是在threading之后设计的，旨在作为基于进程的对应实现。  
    很难终止一个正在运行的线程，这可能会对代码和时空连续性造成各种问题。  
    要使用线程，程序的所有代码以及其使用的外部库都必须是线程安全的。  
    在例15-6的代码中，由于线程没有共享任何全局变量，因此它们可以独立运行，不出任何问题。  
    在不涉及全局变量时，线程不仅有用，而且还安全。在等待某些I/O操作完成时，线程尤为方便。在这种情况下，线程不会因为数据“打架”，因为每个线程都有完全独立的变量。  
    安全地共享数据的常见方式是在线程中修改变量之前先上软件锁。保证在修改过程中，其他线程不会对其造成干扰。
8. 在Python中，线程并不会提高CPU受限任务的速度，原因在于标准Python系统中称为全局解释器锁（global interpreter lock，GIL）的实现细节。  
    这个存在避免了Python解释器的线程问题，但是实际上会让多线程程序运行速度比对应的单线程版本甚至多进程版本更慢。  
    对于Python，建议做到如下两点：  
        - 使用线程处理I/O限定问题；  
        - 使用进程、联网或事件处理CPU受限问题。
9. Python 3.2标准库引入了concurrent.futures模块，允许你使用线程（I/O受限时）或进程（CPU受限时）调度异步工作池。  
    可以使用该模块跟踪状态并收集结果。
10. 使用map()来定义进程/线程池，会导致在返回之前要等待所有的工作进程/线程结束。
11. 开发者习惯将程序中的耗时部分放入单独的线程或进程中运行。Apache Web服务器采用的就是这种设计。  
    还有一种方法是基于事件编程。基于事件的程序会运行一个核心事件循环，分配任务，并重复该循环。NGINX Web服务器就是这样设计的，其速度通常要快于Apache。
12. gevent是一个基于事件的库，可以神奇地将你编写的命令式代码（imperative code）转换为协程。  
    协程就像生成器，彼此之间可以通信，跟踪自己所处的位置。  
    gevent修改了很多Python标准对象（如socket），从而使用自身机制取代了原有的阻塞方式。  
    这不适用于使用C编写的Python扩展代码（比如某些数据库驱动）。  
    gevent支持猴子补丁（monkey-patching）函数。这些函数会修改标准模块（如socket），直接使用绿色线程而不是调用模块的gevent版本。  
    如果想在整个程序中应用gevent，那么这种方法非常有用，即使那些你无法直接接触到的代码也会被改变。
13. 在末尾添加&符号，将一个程序置入后台运行。该程序仍会运行，但不再侦听键盘。这种方法在Linux、macOS和Windows中都适用。
14. 进程相关函数：

    ```python
    * os模块：
        getpid()                        返回当前进程ID
        getuid()                        返回当前进程的真实用户ID
        getcwd()                        返回表示当前工作目录的字符串
        uname()                         返回当前操作系统的识别信息
        getloadavg()                    返回系统运行队列中最近 1、5 和 15 分钟内的平均进程数
        cpu_count()                     返回系统的 CPU 数量
        system(command)                 在子外壳程序中执行命令
    * subprocess模块：
        getoutput(cmd)                  返回在 shell 中执行 cmd 产生的输出（stdout 和 stderr）
        check_output(args)              附带参数运行命令并返回其输出
        getstatusoutput(cmd)            返回在 shell 中执行 cmd 产生的 (exitcode, output)
        call(args)                      运行由 args 所描述的命令。 等待命令完成，然后返回 returncode 属性
        run(args)                       运行被 arg 描述的指令. 等待指令完成, 然后返回一个 CompletedProcess 实例
    * multiprocessing.Process类：
        Process(target=None, args=())   进程对象表示在单独进程中运行的活动
            start()                         启动进程活动
            terminate()                     终止进程
    ```

## 第 16 章  持久性存储

1. 在处理CSV文件的时候，最好使用标准的csv模块，因为CSV文件远比你想象的复杂。

    ```text
    * 除了逗号，'|'和'\t'（制表符）也是常见的界定符。
    * 有时会有转义序列。如果界定符出现在字段内，那么整个字段都要加上引号或是在界定符前加上转义字符。
    * 文件会有不同的行尾字符。Unix使用'\n'，Microsoft使用'\r\n'，Apple之前使用'\r'，现在改用'\n'
    * 第一行可能包含列名。
    * 以默认选项调用reader()和writer()，各列以逗号分隔，各行以换行符分隔。
    ```

2. 带界定符的文件只能传达两个维度：行（文本行）和列（行内的字段）。如果想在程序之间交换数据结构，则需要以文本方式编码层次结构、序列、集合以及其他结构。
3. 在Python中，解析XML最简单的方法是使用标准模块ElementTree。  
    其他标准Python XML库包括： xml.dom 、 xml.sax  
    这3个XML库都对付不了billion laughs ，可以使用defusedxml库作为其他库的安全前端。
4. billion laughs attack是一种DoS（denial-of-service，拒绝服务）攻击，主要作用于XML文档解析器。它也被称为指数实体扩展攻击，是一种名副其实的XML炸弹。  
5. JSON（JavaScript object notation，JavaScript对象记法）是一种非常流行的数据交换格式，它与Python的紧密契合使其成为程序间数据交换的理想选择。

    ```text
    在尝试编码或解码包括datetime在内的某些对象时可能会产生异常。原因在于JSON标准并没有定义日期或时间类型，你得自己处理。可以将datetime转换为JSON能够理解的值，比如字符串或纪元值。
    还有一种更简单的处理方法，可以使用 json.dumps(now, default=str) 将转换函数str()应用于其不理解的数据类型。
    这是可行的，因为datetime.datetime类的定义包含__str__()方法。

        * json.dumps(obj, default=None)             将 obj 序列化为 JSON 格式的字符串
        * json.loads(s)                             将 字符串 s 反序列化为 Python 对象
    ```

6. isinstance()函数会检查对象obj是否为指定类型。因为在Python中，一切皆为对象，所以isinstance()在任何地方都管用。
7. 与JSON类似，YAML具有键和值，但能够处理更多数据类型，比如日期和时间。标准Python库尚未包含YAML处理，需要安装第三方库来对其进行操作。  
    可以从字符串中加载Python对象，这很危险。如果要导入并不信任的YAML，可以使用safe_load()而不是load()。最好坚持使用safe_load()
8. 标准模块configparser可以处理Windows风格的.ini文件。
9. HDF5是一种用于多维或层次化数值数据的二进制数据格式。  
    它主要应用于科学领域，其中对于大型数据集（GB到TB）的快速随机访问是很常见的要求。  
    HDF5最适合WORM（write once/read many，一次写入/多次读取）应用，这种应用无须担心数据库冲突。  
    HDF5的最新“继任者”是TileDB，用于密集或备用阵列存储。
10. SQL是关系数据库的通用语言。  
    SQL不是API或协议，而是一种声明式语言：只需说明想做什么，不用描述具体怎么做。  
    客户端向数据库服务器发出SQL查询，后者负责具体的查询操作。  
    SQL不区分大小写，但是将其关键字写作大写字母是一种传统做法，以便与列名区分开。
11. DB-API是用于访问关系数据库的Python标准API。  
    使用占位符（placeholder）是一种更安全的数据插入方法，以避免遭受 SQL 注入攻击。
12. 最流行的跨数据库Python库是SQLAlchemy。  
    SQLAlchemy能根据连接字符串推测出该用哪种驱动程序。只需修改连接字符串就可以将代码移植到另一种数据库中。  
    SQLAlchemy支持数据库连接池。  
    SQLAlchemy的对象关系映射（ORM）会使用SQL表达式语言，但会尽量隐藏实际的数据库机制。  
    ORM是一种抽象概念，而所有的抽象概念都是有漏洞的，在某些时候会出问题。  
    有些人在碰到问题时会想：我知道我得使用ORM。那么，他们现在有两个问题了。  
    将ORM用于简单应用或是能将数据直接映射到数据库表的应用。  
    如果应用足够简单，你也可以考虑直接使用SQL或SQL表达式语言。

## 第 17 章  网络

1. 互联网基于各种规则：如何创建连接、交换数据、终止连接、处理超时等。  
    这些规则称为协议，以分层的方式组织在一起。  
    分层的目的在于允许创新和出现替代方法。  
    只要遵循上层和下层的约定，你就可以在某一层中“为所欲为”。
2. 传输层协议：

    ```text
    UDP（user datagram protocol，用户数据报协议）
        用于简短的数据交换。数据报是一次性发送的短消息。
    TCP（transmission control protocol，传输控制协议）
        用于长期连接。该协议会发送字节流，确保数据按序到达，不出现重复。
    ```

3. 本地主机的IP地址始终为127.0.0.1，主机名始终为localhost。这称为环回接口。
4. 网络编程的最底层会使用套接字，其出自C语言和Unix操作系统。
5. UDP在单个数据报中发送数据，但并不保证数据发送成功。  
    如果通过UDP发送多个消息，则有可能不按顺序到达接收方，或者根本就到达不了。  
    UDP速度快、轻量、无连接，但是并不可靠。  
    如果需要快速发送分组，同时能够忍受时不时出现丢包，比如VoIP（voice over IP），那么UDP就有用武之地了。
6. TCP按发送顺序投递数据。如果出现问题，则会尝试重新发送。  
    这使得TCP的速度略慢于UDP，但如果要求所有分组按序到达接收方，那么TCP通常是更好的选择。
7. HTTP协议的前两个版本均基于TCP，HTTP/3则基于QUIC协议，后者本身就使用UDP。因此，选择UDP还是TCP涉及诸多因素。
8. ZeroMQ是一个库，不是服务器。ZeroMQ有时被描述为增强版套接字（socket on steroid）  
    消息需要以字节字符串的形式发送，本例将其文本字符串编码为UTF-8格式。  
    你可以发送任何你喜欢的消息，只要将消息转换为bytes类型。  
    我们使用简单的文本字符串作为消息，encode()和decode()足以完成两种形式之间的转换。  
    如果你还有其他类型的消息，可以使用MessagePack等库。  
    ZeroMQ最值得留意的特性是可以通过在创建套接字时改变其连接类型来扩大和缩小规模。
9. Python提供了pickle模块来保存和恢复采用特殊二进制格式的对象。  
    pickle模块可以将对象转换为二进制串，将其转换回对象时则创建副本。  
    dump()可以将序列化后的对象写入文件，load()可以将文件中的序列化对象读出。  
    因为pickle能够创建Python对象，所以先前讨论过的相同的安全告警同样适用。不要使用pickle对不信任的东西反序列化。
10. 远程过程调用（remote procedure call，RPC）看起来就像普通的函数，但是在网络上的远程机器中执行的。  
    标准库中包含了一种使用XML作为交换格式的RPC实现：xmlrpc  
    gRPC是Web REST API的顶层替代方案。它似乎比REST更适合于服务间的通信，而REST可能更适合于公共API

## 第 18 章  Web

1. Web是一种客户端–服务器系统。  
    客户端向服务器发出请求：打开TCP/IP连接，通过HTTP发送URL和其他信息，接收响应。  
    HTTP是用于Web数据交换的标准协议。  
    HTTP的一个重要方面是其无状态性。HTTP连接之间相互独立。  
    解决无状态的方法包括cookie，其中服务器向客户端发送足够的特定信息，以便在客户端发回cookie时能够唯一地识别它。
2. telnet允许你连接任意服务器和端口，向在其中运行的服务输入命令。如果需要安全（加密）连接，则可以使用ssh代替。
3. 80端口通常是未经加密的http，加密的https使用端口443
4. http.server模块只适合进行测试，不适合在生产环境中使用。
5. Web服务器网关接口（Web server gateway interface，WSGI）的定义促成了Python Web开发的飞跃，WSGI是Python Web应用和Web服务器之间的通用接口。  
    ASGI（asynchronous server gateway interface，异步服务器网关接口）是使用异步特性的WSGI的对应物。
6. Apache Web服务器的最佳WSGI模块是mod_wsgi。它可以在apache进程中或是与Apache通信的单独进程中运行Python代码。
7. NGINX Web服务器没有内嵌的Python模块。  
    它是独立的WSGI服务器（比如uWSGI或gUnicorn）的前端。两者共同为Python Web开发提供了一个快速的可配置平台。
8. 在众多的Python Web框架中，Flask是我的最爱，它在易用性和丰富特性之间取得了平衡。  
    flask包括werkzeug WSGI库和jinja2模板库。  
    在调用run()时，将debug设置为True，如果服务器代码出现异常，那么Flask就会返回一个特殊格式的页面，其中包含详细的出错信息。  
    更妙的是，还可以输入一些命令来查看服务器程序中变量的值。  
    不要在生产环境的Web服务器中设置debug=True。这会向潜在的入侵者暴露过多有关服务器的信息。  
    可以使用字典的 `**` 操作符来向模板一次性传入字典中的多个值。
9. webbrowser可以控制浏览器完成所有工作。
10. 如果已经有了网站的HTML数据，只想从中提取数据，那么BeautifulSoup是一个不错的选择。  
    HTML解析远比听起来要难，因为很多公共页面的HTML在技术上是不合法的：未闭合的标签、不正确的嵌套结构以及其他各种问题。
11. 大部分Web API要求你先获得API密钥，并在每次访问API时提供该密钥。为什么呢？这就是一场公地悲剧（tragedy of the commons）：可以匿名访问的免费资源经常被过度使用或滥用。这就是为什么我们无法拥有美好的事物。

## 第 19 章  成为Python主义者

1. 安装Python包的方法有很多种。

    ```text
    * 使用pip，这是目前最常见的方法。可以通过pip安装大多数的Python包。
    * 使用结合了pip和virtualenv的pipenv
    * 有时可以使用操作系统的包管理器。
    * 如果要从事大量科学工作并希望使用Python的Anaconda发行版，那么可以使用conda
    * 从源代码安装。
    ```

2. 如果对同一领域的多个软件包感兴趣，你也许会发现某个Python发行版已经将这些包纳入其中。
3. 安装第三方包的标准方式是使用pip和virtualenv
4. 虚拟环境只是一个包含Python解释器、其他程序（如pip）和一些包的目录。  
    虚拟环境可以通过运行其中bin目录内的shell脚本activate来激活。这会设置shell用于查找程序的环境变量$PATH  
    激活虚拟环境后，其bin目录被放在了$PATH所包含的常用目录之前。  
    当你输入pip或python等命令时，shell首选找到的是虚拟环境中的相应程序，而不再是/bin、/usr/bin或/usr/local/bin等系统目录中的那些。
5. pipenv结合了pip和virtualenv的特性。它还解决了在不同环境（开发环境、暂存环境、生产环境）中使用pip产生的依赖性问题。  
    pipenv得到了Python Packaging Authority的推荐。
6. 要留心下载和安装的文件。想在可读的Python程序中隐藏恶意软件有点儿难度，但也不是不可能。
7. Python没有常量，但是PEP8代码风格指南推荐在命名应该被视为常量的变量时使用大写字母和下划线（如ALL_CAPS）
8. Python变量只是引用实际对象的名称。  
    对象有严格的类型，名称可以在任何时刻指向任何对象。
9. Python 3.x添加了类型提示（类型注解）。  
    这项特性是可选的，并不带有强制性。  
    这些只是提示，并不会改变Python的工作方式。  
    FastAPI Web框架可以利用类型提示来生成带有可用于测试的实时表单。
10. 即使是微不足道的代码改动，也会对程序造成破坏。测试必不可少。  
    print()语句不应该出现在生产代码中，可别忘了将其全部删除。
11. 标准库中包含两个测试包：unittest 和 doctest
12. 在调试的时候，通常都是“自底向上”，从最近做出的改动开始检查。  
    你觉得如果很多人使用的东西有问题，那么应该已经有人注意到了，但事实并非总是如此。
13. 使用print()进行调试时，可以打印 vars()、locals()、globals() 的值试试。
14. 装饰器可以在不修改函数代码的前提下，在函数执行之前或之后调用代码。
15. 标准Python调试器是pdb  
    Python 3.7新增内建函数breakpoint()。如果将其添加到你的代码中，那么调试器会自动启动并在每个位置暂停。  
    如果没有该函数，则必须手动启动调试器（如pdb）并设置断点。
16. 标准库日志模块是logging  
    默认的优先级是WARNING，一旦调用第一个函数（logging.debug()），它就会被锁定。  
    可以使用basicConfig()设置默认级别。  
    logging模块包含至少15个处理程序，可以将消息发送至电子邮件、Web服务器、屏幕、文件等地方。
17. 测试相关函数：

    ```python
    * time模块：
        time()                          以浮点数形式返回纪元时间（以秒为单位）
        sleep(secs)                     将调用线程的执行挂起给定的秒数
    * timeit模块：
        timeit(stmt='pass', number=1000000)                     计算一小段 Python 代码的耗时
        repeat(stmt='pass', repeat=5, number=1000000)           使用给定的 repeat 计数和 number 执行给定语句
    ```

18. 一般来说，推导式快于手动构建。
19. Python并不会被编译为机器语言，而是被翻译为一种中间语言（叫作字节码或p-code），然后再由虚拟机解释执行。

## 第 20 章  Python的艺术

1. 标准库中图像相关的模块有 colorsys、turtle 和 imghdr（计划Python3.13移除）
2. 标准库GUI模块是tkinter

## 第 21 章  工作中的Python

1. 使用下列工具，可以创建出更快、更便宜且更灵活的应用。

    ```text
    * Python等动态语言。
    * 作为通用图形用户界面的Web
    * 作为语言无关服务接口的RESTful API
    * 关系数据库和NoSQL数据库。
    * “大数据”和分析法。
    * 用于部署和资本节约的云。
    ```

## 第 22 章  Python的科学

1. 标准库math模块包含大量的数学函数。
2. Python语言完全支持复数及其实部和虚部记法。  
    一些复数数学函数位于标准cmath模块中。
3. 使用Python的decimal模块可以将数字以所需的任意精度表示。这对于涉及金钱的计算尤其重要。  
    使用字符串值初始化Decimal，以保留其有效性。
4. 标准模块fractions将数字表示为分子除以分母的形式。
5. Python列表更像是链表而非数组。  
    如果想要相同类型元素组成的一维序列，那么可以使用array类型。  
    它比列表占用的空间更少，支持多种列表方法。
6. statistics标准模块（Python 3.4）包含许多实用统计函数：均值、中位数、求模、标准差、方差，等等。
7. 从Python 3.5开始，字符 @ 可用于矩阵乘法。  
    如果你使用的是旧版Python，那么NumPy是最佳选择。
8. NumPy是Python得以在科学家中流行的主要原因之一。  
    NumPy的核心数据结构：多维数组ndarray（N-dimensional array）和 array  
    与Python的列表和元组不同，ndarray的每个元素类型必须相同。  
    reshape()对改变形状的唯一限制是秩的乘积要等于数组元素的总数。  
    NumPy批量操作适用于加法、减法、乘法、除法以及NumPy库中的其他函数。  
    NumPy包含许多与线性代数相关的函数。  
    NumPy还提供了与多项式、傅里叶变换、统计以及一些概率分布相关的模块。
9. SciPy是建立在NumPy基础之上的库，拥有更多的数学函数和统计函数。

## 附录

1. PyPA（Python Packaging Authority）是一个尝试简化Python打包的志愿者工作组（不属于官方Python开发核心组）。  
    该小组编写了Python打包用户指南（Python Packaging User's Guide），其中讨论了目前的问题及解决方案。  
    最出类拔萃的打包方式还是conda，特别是对于科学和数据密集型应用。
2. 和多数编程语言一样，Python也是同步的。  
    Python以线性方式运行代码，一次一行，从头到尾。  
    当你调用函数时，Python会转入函数代码，调用方则一直等待，直到函数返回，然后再恢复先前的操作。
3. Python 3.4添加了标准异步模块 asyncio，Python 3.5添加了关键字 async 和 await  
    这实现了一些新概念。  
        1、协程，可以在任意点暂停的函数。  
        2、事件循环，调度和运行协程。
4. 协程比线程轻量得多。我们可以在仅支持数千个线程的机器上创建数十万个协程。
