0、Python语言规范：
    在Python中，一切皆是对象；
    Python是强类型语言；(备注：出自Python语言及其应用（第2版），但Python变量却可以指向不同类型的值。)
    Python区分大小写；
    Python没有指针；

0、PEP-8 编程风格：(出自Python官方文档)
    缩进，用 4 个空格，不要用制表符。4 个空格是小缩进（更深嵌套）和大缩进（更易阅读）之间的折中方案。制表符会引起混乱，最好别用。
    换行，一行不超过 79 个字符。这样换行的小屏阅读体验更好，还便于在大屏显示器上并排阅读多个代码文件。
    用空行分隔函数和类，及函数内较大的代码块。
    最好把注释放到单独一行。
    运算符前后、逗号后要用空格，但不要直接在括号内使用： a = f(1, 2) + g(3, 4)。
    类和函数的命名要一致；按惯例，命名类用 UpperCamelCase，命名函数与方法用 lowercase_with_underscores。命名方法中第一个参数总是用 self 。
    编写用于国际多语环境的代码时，不要用生僻的编码。Python 默认的 UTF-8 或纯 ASCII 可以胜任各种情况。
    同理，就算多语阅读、维护代码的可能再小，也不要在标识符中使用非 ASCII 字符。
    常量通常在模块级定义，并用大写字母书写，用下划线分隔单词。

    使用文档字符串：
        第一行应为对象用途的简短摘要；
        为保持简洁，不要在这里显式说明对象名或类型，因为可通过其他方式获取这些信息（除非该名称碰巧是描述函数操作的动词）；
        这一行应以大写字母开头，以句点结尾；
        文档字符串为多行时，第二行应为空白行，在视觉上将摘要与其余描述分开；
        后面的行可包含若干段落，描述对象的调用约定、副作用等；

1、Python的基本数据类型：
    类型        名称        是否可变
    bool        布尔值      否
    int         整数        否
    float       浮点数      否
    complex     复数        否
    str         文本字符串  否
    bytes       字节序列    否
    bytearray   字节数组    是
    list        列表        是
    tuple       元组        否
    set         集合        是
    frozenset   冻结集合    否
    dict        字典        是

2、Python通用函数和语法：
    len()        获取长度
    del          删除    （这个不是函数）
    in           测试是否包含
    for in       迭代序列
    sum()        求和
    id()         对象标识
    locals()     局部名称空间对象
    globals()    全局名称空间对象
    vars()       函数参数
    type()       类型检查
    divmod()     在作整数除法时，返回商和余数的元组
    bin()        将整数转变为以“0b”前缀的二进制字符串
    oct()        将一个整数转变为一个前缀为“0o”的八进制字符串
    hex()        将整数转换为以“0x”为前缀的小写十六进制字符串
    chr()        返回 Unicode 码位为整数 i 的字符的字符串格式
    ord()        对表示单个 Unicode 字符的字符串，返回代表它 Unicode 码点的整数
    int()        返回一个基于数字或字符串 x 构造的整数对象，或者在未给出参数时返回 0
    float()      返回从数字或字符串 x 生成的浮点数

3、Python的特殊方法（魔术方法）：
    __eq__          ==
    __ne__          !=
    __lt__          <
    __gt__          >
    __le__          <=
    __ge__          >=

    __add__         +
    __sub__         -
    __mul__         *
    __floordiv__    //
    __truediv__     /
    __mod__         %
    __pow__         **

    __str__         str()
    __repr__        repr()
    __len__         len()
    __init__        初始化

4、Python变量命名规则：
    只能包含：大写字母、小写字母、数字、下划线；
    必须以字母或下划线开头，以下划线开头的名称会做特殊处理；
    不能是Python保留字；

5、逻辑值检测：
    任何对象都可以进行逻辑值的检测，以便在 if 或 while 作为条件或是作为下文所述布尔运算的操作数来使用。
    一个对象在默认情况下均被视为真值，除非当该对象被调用时其所属类定义了 __bool__() 方法且返回 False 或是定义了 __len__() 方法且返回零。
    下面基本完整地列出了会被视为假值的内置对象:
        被定义为假值的常量: None 和 False
        任何数值类型的零: 0, 0.0, 0j, Decimal(0), Fraction(0, 1)
        空的序列和多项集: '', (), [], {}, set(), range(0)
    产生布尔值结果的运算和内置函数总是返回 0 或 False 作为假值，1 或 True 作为真值，除非另行说明。（重要例外：布尔运算 or 和 and 总是返回其中一个操作数。）
    函数bool()能将任意的Python数据类型转换为布尔值。
    为了区分None与布尔值False，需要使用is运算符： obj is None

6、除了索引，字符串还支持切片。索引可以提取单个字符，切片则提取子字符串。
    切片索引的默认值很有用；省略开始索引时，默认值为 0，省略结束索引时，默认为到字符串的结尾；
    注意，输出结果包含切片开始，但不包含切片结束。因此，s[:i] + s[i:] 总是等于 s ;
    对于使用非负索引的切片，如果两个索引都不越界，切片长度就是起止索引之差。例如，word[1:3] 的长度是 2 ;
    索引越界会报错：但是，切片会自动处理越界索引。比字符串起始位置还靠前的偏移被视为 0 ，超出结束位置的偏移被视为 -1 ;

7、Python频繁地用到迭代器，这是有充分理由的。迭代器允许你遍历数据结构，无须知道其具体大小和实现。你甚至可以一边创建一边迭代数据，借此处理无法一次性全部读入计算机内存的数据流。
7、itertools模块包含很多特殊用途的迭代器函数，尤其是一些用于组合和排列的函数，合理使用可以节省大量时间。

11、Python字符串：
    -0 和 0 一样，因此，负数索引从 -1 开始；
    字符串不能修改，是 immutable 的。因此，为字符串中某个索引位置赋值会报错；
    内置函数 len() 返回字符串的长度（Unicode字符数，而非字节数）：
    字符串是序列类型，支持序列类型的各种操作；
    单引号或双引号都可以创建字符串，三引号可以创建多行字符串；
    当你对非字符串对象调用print()以及格式化字符串时，Python会在内部使用str()函数；
    字符串没有reverse()函数，可以使用切片实现这个功能：str[::-1]
    Python3的字符串是Unicode字符序列，而非字节数组。这是Python2到Python3最大的变化；

11、Python特殊类型字符串：
    f或F：格式化字符串
    r或R：原始字符串
    u或U：Unicode字符串
    b或B：类型 bytes 的实例

11、Unicode字符串：
    \uffff          Unicode基本多语言平面字符
    \Uffffffff      高平面字符（高位必须写作0）
    \N{name}        指定名称对应的字符

    ord()           字符转整数编码值
    chr()           整数编码值转字符
    encode()        将字符串编码为字节序列
    decode()        将字节序列解码为字符串

    unicodedata模块：
        lookup()    接受字符名称（不区分大小写），返回对应的Unicode字符
        name()      接受Unicode字符，返回对应的字符名称
        normalize() 对Unicode编码做归一化处理

11、正则表达式模式匹配由标准模块re提供：
    为避免正则表达式中的特殊字符和Python转义字符的冲突，可以使用原始字符串禁用转义序列。
    match()         返回起始位置匹配内容（如果有的话）
    search()        返回首次匹配（如果有的话）
    findall()       返回所有匹配（如果有的话）
    split()         按模式匹配进行分割，返回子串列表
    sub()           替换所有模式匹配

12、Python列表：
    与 immutable 字符串、元组不同, 列表是 mutable 类型，其内容可以改变。
    元组和列表可以包含不同类型的元素，但一般情况下，各个元素的类型相同。每个元素可以是任意的Python对象。
    当列表中某个位置上的内容被删除后，位于其后的列表项会向前移动，补上空出的位置，并且列表长度减1 。
    如果使用append()将新的列表项添加到尾部，使用pop()从尾部删除列表项，就是栈结构（LIFO后进先出）；使用pop(0)从头部删除列表项，则是队列结构（FIFO先进先出）。
        然而，列表作为队列的效率很低。因为，在列表末尾添加和删除元素非常快，但在列表开头插入或移除元素却很慢（因为所有其他元素都必须移动一位）。实现队列最好用 collections.deque，可以快速从两端添加或删除元素。
    使用copy()、list()、或切片复制列表，返回的是列表的浅拷贝；使用deepcopy()可以返回列表的深度拷贝。
    列表推导式创建列表的方式更简洁。常见的用法为，对序列或可迭代对象中的每个元素应用某种操作，用生成的结果创建新的列表；或用满足特定条件的元素创建子序列。
    列表推导式可以使用复杂的表达式和嵌套函数。

13、Python元组：
    虽然，元组与列表很像，但使用场景不同，用途也不同。元组是 immutable（不可变的），一般可包含异质元素序列，通过解包或索引访问（如果是 namedtuples，可以属性访问）。列表是 mutable （可变的），列表元素一般为同质类型，可迭代访问。
    具名元组是元组的子类，可以按名称（.name）或位置（[offset]）访问值。具名元组是不可变的。
    具名元组具有以下优点：
        外观和行为都像是一个不可变对象；
        比对象更节省空间和时间；
        可以使用点号记法代替字典式的中括号记法访问特性；
        可以将其用作字典键；

14、Python集合：
    遍历某个集合的同时修改该集合的内容，很难获取想要的结果。要在遍历时修改集合的内容，应该遍历该集合的副本或创建新的集合。
    创建集合用花括号或 set() 函数。注意，创建空集合只能用 set()，不能用 {}，{} 创建的是空字典。
    集合是无序的。
    集合支持：
        交集    &    intersection()     
        并集    |    union()
        差集    -    difference()
        异或集  ^    symmetric_difference()
        子集    <=   issubset()
        真子集  <
        超集    >=   issuperset()
        真超集  >
    使用frozenset()可以创建不可变集合。

15、Python字典：
    字典以“关键字”为索引，关键字通常是字符串或数字，也可以是其他任意不可变类型。    
    使用 [key] 获取字典项时，如果键不存在会抛出异常；使用函数 get() 获取字典项则不会抛出异常，如果指定键不存在，get() 函数会返回None或指定的可选值。
    可以使用 keys() 获取所有的键，使用 values() 获取所有值，使用 item() 获取所有 “键-值” 对，使用 enumerate() 函数可以同时取出位置索引和对应的值。
        在Python2中，keys()返回一个列表。在Python3中，keys()会返回dict_keys()，这是键的可迭代视图。对于大型字典，这种做法很方便，因为无须再花费时间和内存来创建和存储你可能并不会使用的列表。但很多时候你的确想要一个列表。在Python3中，需要调用list()将dict_keys对象转换为列表。
    从Python3.5开始，可以使用{**a, **b}合并字典。通过这种方法得到的都是浅复制。
    使用pop()可以按键获取字典项并将其删除，如果键不存在会抛出异常，可以指定可选的返回值。
    使用copy()进行字典的浅拷贝；使用deepcopy()可以进行深度拷贝。
    setdefault()函数可以在键缺失时添加字典项。如果缺失某个键，就使用指定的新值；如果键已存在，则返回原始值，不做任何改动。
    defaultdict()会在创建字典时为每个新键指定默认值。它的参数是一个函数，其返回值会被赋给缺失的键。可以使用函数int()、list()和dict()返回默认的空值：int()返回0，list()返回空列表（[]），dict()返回空字典（{}）。如果忽略该函数参数，则新键的初始值会被设置为None。
    从Python3.7开始，字典会保留键被添加时的顺序。

16、函数：
    代码重用的第一步是使用函数。函数是独立于其他代码的具名的代码段。
    如果函数没有明确使用return，则调用者得到的返回结果为None。
    默认形参值是在定义函数时而不是在运行函数时求值。重要警告：默认值只计算一次。默认值为列表、字典或类实例等可变对象时，会产生与该规则不同的结果。
    在调用函数时会将实际参数（实参）引入到被调用函数的局部符号表中；因此，实参是使用按值调用来传递的（其中的值始终是对象的引用而不是对象的值）。Python函数参数的传递形式类似于Java的按引用传递，可变参数在函数内的修改会对实参造成同样的影响。
    函数是Python的“头等公民”，你可以将其赋值给变量，用作其他函数的参数和返回值。
    函数也是对象。
    可以使用函数作为列表、元组、集合以及字典的元素。由于函数是不可变的，因此也可以将其用作字典的键。
    可以在一个函数的内部定义另一个函数（内部函数）。内部函数可以作为闭包，闭包是一个动态创建的函数，能够记住创建时所在的环境。

    函数形参定义：
        函数调用时，关键字参数必须跟在位置参数后面。所有传递的关键字参数都必须匹配一个函数接受的参数；
        使用仅限位置形参，可以让用户无法使用形参名。形参名没有实际意义时，强制调用函数的实参顺序时，或同时接收位置形参和关键字时，这种方式很有用；
        当形参名有实际意义，且显式名称可以让函数定义更易理解时，阻止用户依赖传递实参的位置时，才使用关键字；
        对于API，使用仅限位置形参，可以防止未来修改形参名时造成破坏性的API变动；

    lambda函数：
        lambda函数是一个可表达为单语句形式的匿名函数。你可以用它来代替普通的微型函数；
        lambda 关键字用于创建小巧的匿名函数。lambda a, b: a+b 函数返回两个参数的和；
        Lambda函数可用于任何需要函数对象的地方；
        在语法上，匿名函数只能是单个表达式；
        在语义上，它只是常规函数定义的语法糖；
        与嵌套函数定义一样，lambda 函数可以引用包含作用域中的变量；

17、类：
    对象是包含数据和代码的自定义数据结构。
    __init__()并不是其他语言中的“构造函数”，Python已经替你把对象构造好了，不妨将其视为初始化函数。当你在类定义中编写__init__()时，第一个参数应该是self，尽管self在Python中并非保留字，但这是一种惯常用法。
    可以使用issubclass()检查一个类是否从另一个类派生而来。
    继承很吸引人，但也会被滥用。
    Python支持多重继承。Python继承的特性或方法取决于方法解析顺序，解析顺序按广度优先进行。每个Python类都有一个特殊方法mro()，可以返回一个类列表，用于查找该类对象的方法或特性。还有一个类似的特性__mro__，是由这些类组成的元组。
    实际上，在Python中没有任何东西能强制隐藏数据 --- 它是完全基于约定的。
    Python中并不存在“私有”实例变量。但是，大多数Python代码都遵循这样一个约定：带有一个下划线的名称应该被当作是API的非公有部分(无论它是函数、方法或是数据成员)。这应当被视为一个实现细节，可能不经通知即加以改变。
    对于特性隐私，Python式的解决方案是使用属性。有两种方法：第一种方法是把 name = property(get_name, set_name) 作为类定义的最后一行；第二种是加入@property和@name.setter注解。
    可以为类设置各种特性，这些特性会被类的子对象继承。
    和模块一样，类也拥有Python天然的动态特性：在运行时创建，创建后也可以修改。
    Python松散地实现了多态，可以根据方法的名称和参数将相同的操作应用于不同的对象，不管他们的类是什么。

17、Python3.7 引入了数据类。除了需要 @dataclass装饰器，定义类特性的时候要使用形如 name: type 或 name: type=val 的变量注解。
17、有些方法属于类本身，有些方法属于该类的对象，有些则两者都不属于。
    如果没有前置装饰器，就是实例方法，其第一个参数应该是self，引用对象本身；
    如果有前置装饰器@classmethod，就是类方法，其第一个参数应该是cls，引用类本身；
    如果有前置装饰器@staticmethod，就是静态方法，其第一个参数不能是对象或类；

18、模块：
    模块就是包含任意Python代码的文件。
    一个Python模块无论在程序中被引用了多少次，都只装载一个副本。
    模块包含可执行语句及函数定义。这些语句用于初始化模块，且仅在 import 语句第一次遇到模块名时执行。
    还有一种变体可以导入模块内定义的所有名称：
        from fibo import *
        这种方式会导入所有不以下划线（_）开头的名称。
        大多数情况下，不要用这个功能，这种方式向解释器导入了一批未知的名称，可能会覆盖已经定义的名称。

19、异常处理：
    所有异常都继承自BaseException，因此它可被用作通配符。
    不论是以直接还是间接的方式，异常都应从Exception类派生。
    大多数异常命名都以“Error”结尾，类似标准异常的命名。
    try...except 语句具有可选的else子句，该子句如果存在，它必须放在所有except子句之后。它适用于try子句没有引发异常但又必须要执行的代码。
    raise语句支持强制触发指定的异常。

    如果存在finally子句，则finally子句是try语句结束前执行的最后一项任务。
        不论try语句是否触发异常，都会执行finally子句。以下内容介绍了几种比较复杂的触发异常情景：
            如果执行try子句期间触发了某个异常，则某个except子句应处理该异常。如果该异常没有except子句处理，在finally子句执行后会被重新触发。
            except或else子句执行期间也会触发异常。同样，该异常会在finally子句执行之后被重新触发。
            如果finally子句中包含break、continue或return语句，异常将不会被重新引发。
            如果执行try语句时遇到break、continue或return语句，则finally子句在执行break、continue或return语句之前执行。
            如果finally子句中包含return语句，则返回值来自finally子句的某个return语句的返回值，而不是来自try子句的return语句的返回值。

20、推导式：
    列表推导式：
        [value for item in iterable]
        [value for item in iterable if condition]
    集合推导式：
        {value for item in iterable}
        {value for item in iterable if condition}
    字典推导式：
        {key : value for item in iterable}
        {key : value for item in iterable if condition}
    生成器推导式：
        (value for item in iterable)
        (value for item in iterable if condition)

21、生成器是一个Python序列生成对象。
    有了它，你就可以对可能会很长的序列进行迭代，无须一次性在内存中创建并保存整个序列。
    每次迭代生成器，都会记录上次被调用时所在的位置并返回下一个值。这一点和普通函数不同，后者并不会记录之前的调用，总是以同样的状态从函数的第一行代码开始执行。
    生成器通过yield语句而非return语句返回值。
    生成器只能运行一次。列表、集合、字符串和字典存在于内存之中，而生成器是动态生成值，迭代器会将其一次一个送出。由于生成器并不会记忆这些值，因此你无法重启或备份生成器。

22、日期和时间：
    表示绝对时间的一种方法是计算从某个时间起点开始的秒数。Unix时间使用自1970年1月1日0点开始的秒数。这个值通常称为纪元（epoch），它是在系统之间交换日期和时间的最简单方法；
    纪元值是与不同系统交换日期和时间时的最小公分母；
    尽可能使用UTC代替时区。UTC是绝对时间，与时区无关；
    尽可能避免使用夏令时；
    使用strftime()将日期时间格式化为字符串；
    使用strptime()将字符串解析为日期时间；

23、文件和目录：
    读取文件最简单的方法是使用迭代器，每次返回一行；
    如果忘记关闭打开过的文件，那么Python会在该文件不再被引用时将其关闭。这意味着如果在函数内打开了文件，但没有关闭，那么当函数结束时，该文件会被自动关闭；
    在处理文件对象时，最好使用with关键字：
        优点是，子句体结束后，文件会正确关闭，即便触发异常也可以；
        而且，使用with相比等效的try-finally代码块要简短得多：
        如果没有使用with关键字，则应调用f.close()关闭文件，即可释放文件占用的系统资源；
        警告：调用f.write()时，未使用with关键字，或未调用f.close()，即使程序正常退出，也**可能**导致f.write()的参数没有完全写入磁盘；
    在文本模式下读取文件时，默认把平台特定的行结束符（Unix上为\n，Windows上为\r\n）转换为\n。在文本模式下写入数据时，默认把\n转换回平台特定结束符；
    可以使用BytesIO和StringIO将数据包装成类文件对象；

    fileobj = open( filename, mode)
        mode的第一个字符：
            r       读取
            w       写入：不存在则创建，存在则覆盖
            x       不存在时写入，存在抛出异常
            a       存在时追加，不存在抛出异常
        mode的第二个字符：
            t       文本文件，默认值
            b       二进制文件

    with open( filename, mode) as fout:

    常用函数：
        open()          打开文件
        close()         关闭文件
        read()          读取
        write()         写入
        readline()      读取一行
        readlines()     按行读取
        seek()          跳转到指定偏移位置，主要用于二进制文件
        tell()          查看当前偏移位置
        exists()        检查文件是否存在
        isfile()        检查文件类型
        copy()          复制文件
        move()          移动文件
        remove()        删除文件
        rename()        重命名
        chmod()         改变文件权限
        chown()         改变文件所属权
        mkdir()         创建目录
        rmdir()         删除目录
        listdir()       列出目录
        chdir()         改变当前目录
        glob()          查找匹配文件
        abspath()       获取绝对路径

24、进程和线程：
    multiprocessing是在threading之后设计的，旨在作为基于进程的对应实现；
    要使用线程，程序的所有代码以及其使用的外部库都必须是线程安全的；
    在不涉及全局变量时，线程不仅有用，而且还安全。在等待某些I/O操作完成时，线程尤为方便。在这种情况下，线程不会因为数据“打架”，因为每个线程都有完全独立的变量；
    在Python中，线程并不会提高CPU受限任务的速度，原因在于标准Python系统中称为全局解释器锁（global interpreter lock, GIL）的实现细节。这个存在避免了Python解释器的线程问题，但是实际上会让多线程程序运行速度比对应的单线程版本甚至多进程版本更慢；
    开发者习惯将程序中的耗时部分放入单独的线程或进程中运行；
    还有一种方法是基于事件编程。基于事件的程序会运行一个核心事件循环，分配任务，并重复该循环；
    gevent是一个基于事件的库，可以神奇地将你编写的命令式代码转换为协程。协程就像生成器，彼此之间可以通信，跟踪自己所处的位置。gevent修改了很多Python标准对象，从而使用自身机制取代了原有的阻塞方式。这不适用于使用C编写的Python扩展代码（比如某些数据库驱动）；
    Python3.4添加了标准异步模块asyncio，Python3.5添加了关键字async和await；
    可以通过将async放在def之前来定义协程；
    协程比线程轻量的多，我们可以在仅支持数千个线程的机器上创建数十万个协程；

    对于Python，建议做到如下两点：
        使用线程处理I/O限定问题；
        使用进程、联网或事件处理CPU受限问题；

25、DB-API是用于访问关系数据库的Python标准API。主要函数如下：
        connect()       创建数据库连接
        cursor()        创建cursor对象
        execute()       运行SQL命令
        executemany()   运行多条SQL命令
        fetchone()      获取执行结果
        fetchmany()     获取执行结果
        fetchall()      获取执行结果

    使用占位符是一种更安全的数据操作方法，可以有效避免遭受SQL注入攻击。
    最流行的跨数据库Python库是SQLAlchemy。SQLAlchemy可以在3个层面操作数据库：
        SQLAlchemy引擎，类似于DB-API函数，但也有连接池等优势；
        SQLAlchemy表达式语言，能够方便处理SQL方言差异；
        SQLAlchemy ORM，以Python对象方式操作数据库；
    ORM是一种抽象概念，而所有的抽象概念都是有漏洞的，在某些时候会出问题。当ORM不能满足你的需求时，必须弄清楚其工作原理以及如何在SQL中修复。

26、网络编程：网络编程的最底层会使用套接字。
    TCP基于长连接，按发送顺序投递数据。如果出现问题，则会尝试重新发送。这使得TCP的速度略慢于UDP；
    UDP在单个数据报中发送数据，但并不保证数据发送成功。如果通过UDP发送多个消息，则有可能不按顺序到达接收方，或者根本就到达不了。UDP速度快、轻量、无连接，但是并不可靠；
    HTTP协议的前两个版本均基于TCP，HTTP3则基于QUIC协议，后者本身就使用UDP；
    ZeroMQ最值得留意的特性是可以通过在创建套接字时改变其连接类型来适应服务间、进程间、线程间的通信；
    gRPC是 Web REST API 的顶层替代方案。它更适合于服务间通信，而REST更适合于公共API；

27、Web开发:
    WSGI（Web server gateway interface 服务器网关接口）是Python Web应用和Web服务器之间的通用接口；
    ASGI（asynchronous server gateway interface 异步服务器网关接口）是与WSGI对应的异步方式；
    0.0.0.0 表示任意IP地址，Web客户端可以使用服务器的任意地址来访问；
    在众多的Python Web框架中，Flask是我的最爱，它在易用性和丰富特性之间取得了平衡。Flask包括jinja2，这是一个功能更为丰富的模板系统；
    Django是一款颇为流行的Python Web框架，尤其适合于大型站点；

28、代码优化：
    调试：
        在调试的时候，通常都是“自底向上”，从最近做出的改动开始检查。
        你觉得如果很多人使用的东西有问题，那么应该已经有人注意到了，但事实并非总是如此。
        装饰器可以在不修改函数代码的前提下，在函数执行之前或之后调用代码。
        在Python3.7中，有一个新的内建函数breakpoint()。如果将其添加到你的代码中，那么调试器会自动启动并在每个位置暂停。如果没有该函数，则必须手动启动调试器并设置断点。
    日志：
        Python标准日志模块是logging，它的默认日志级别是WARNING，可以使用basicConfig()设置日志级别。logging模块包含至少15个处理程序，可以将消息发送至电子邮件、Web服务器、屏幕、文件等地方。
    性能优化：
        使用标准模块 timeit.timeit() 可以测试一段代码的执行时间。
        Cython是Python和C的混合体，旨在将带有一些性能注解的Python代码转换为经过编译的C代码。这些注解相当短，但能大大提高运行速度。
        NumPy是一个使用C实现的数学库。
        PyPy是一种新的Python解释器，在基准测试中平均比CPython快6倍以上。
        Numba将Python代码动态编译成机器码，对于NumPy和其他有数学运算要求的包特别有用。

41、除法运算（/）返回浮点数，用 // 运算符执行 floor division 的结果是整数（忽略小数）。
    如果除数为0，则这两个运算符都会抛出异常。
42、循环语句支持else子句：
    for循环中，可迭代对象中的元素全部循环完毕时，或while循环的条件为假时，执行该子句；
    break语句终止循环时，不执行该子句；
    与if语句相比，循环的else子句更像try的else子句：try的else子句在未触发异常时执行，循环的else子句则在未运行break时执行；
43、Python的for语句迭代列表或字符串等任意序列，元素的迭代顺序与在序列中出现的顺序一致。内置函数range()常用于遍历数字序列，该函数可以生成算术级数。
44、以双下划线（__）起止的名称是保留给Python内部使用的，不要将它们与你自己的变量一起使用。
    __name__        函数名称（主程序的名称为__main__）
    __doc__         文档字符串
45、装饰器是一种函数，接受一个函数作为输入并会返回另一个函数。
46、主程序部分定义了全局(global)名称空间，在其中定义的变量就是全局变量。
    要想在函数中访问全局变量而非局部变量，需要明确使用global关键字。
47、使用最简单的方法解决问题。字典、列表或元组要比模块更简单、更小巧且更快速，而模块往往又比类简单。
48、避免过度设计数据结构。元组比对象好（也可以尝试具名元组）。简单的字段优先于 getter/setter 函数…… 内建数据类型是你的好朋友。多用数字、字符串、元组、列表、集合和字典。多看看容器数据类型，尤其是双端队列。    —— Guido van Rossum
49、使用sys.path可以查看Python解释器搜索路径的列表，Python会依次在其中查找要导入的模块，优先使用最先匹配到的项。可以在自己的代码中修改搜索路径。
50、可以使用Counter()进行计数，还可以使用运算符对计数器进行组合。
51、deque是一种双端队列，兼具栈和队列的功能。
52、虚拟环境只是一个包含Python解释器、其他程序和一些包的目录。虚拟环境可以通过运行其中bin目录内的shell脚本activate来激活。这会设置shell用于查找程序的环境变量$PATH。激活虚拟环境后，其bin目录被放在了$PATH所包含的常用目录之前。当你输入pip或python等命令时，shell首先找到的是虚拟环境中的相应程序，而不再是/bin、/usr/bin或/usr/local/bin等系统目录中的那些。
53、Python变量只是引用实际对象的名称。对象有严格的类型，名称可以在任何时刻指向任何对象。
54、在末尾添加&符号，将一个程序置入后台运行。该程序仍会运行，但不再侦听键盘。这种方法在Linux、macOS和Windows中都适用。
55、Python提供了pickle模块来保存和恢复采用特殊二进制格式的对象。因为pickle能够创建Python对象，所以先前讨论过的相同的安全警告同样适用。不要使用pickle对不信任的东西反序列化。
56、有两个工具对Python开发而言几乎是必不可少的：pip和virtualenv
    pip是安装第三方（非标准）Python包最流行的方式；
    pipenv结合了pip和virtualenv，得到了PyPA（Python Packaging Authority —— Python打包机构）的推荐；
    最出类拔萃的打包方式还是conda，特别是对于科学和数据密集型应用；
