# C 程序设计语言（第2版）

## 第 1 章  导言

1. 一个 C 语言程序，无论其大小如何，都是由函数和变量组成的。  
    函数中包含一些语句，以指定所要执行的计算操作；  
    变量则用于存储计算过程中使用的值。
2. 通常情况下，函数的命名没有限制。  
    但main是一个特殊的函数名——每个程序都从main函数的起点开始执行。  
    这意味着每个程序都必须在某个位置包含一个main函数。
3. 用双引号括起来的字符序列称为字符串或字符串常量。
4. 包含在 `/* 与 */` 之间的字符序列（注释）将被编译器忽略。  
    注释可以自由地运用在程序中，使得程序更易于理解。  
    程序中允许出现空格、制表符和换行符之处，都可以使用注释。
5. 在 C 语言中，所有变量都必须先声明后使用。  
    声明通常放在函数起始处，在任何可执行语句之前。  
    声明用于说明变量的属性，它由一个类型名和一个变量表组成。
6. 数据类型的取值范围取决于具体的机器。
7. 在 C 语言中，整数除法操作将执行舍位，结果中的任何小数部分都会被舍弃。
8. printf 函数第一个参数中的 % 和后面的参数在数目和类型上都必须匹配，否则将出现错误的结果。
9. 在允许使用某种类型变量值的任何场合，都可以使用该类型的更复杂的表达式。
10. 使用 #define 指令可以定义符号常量。  
    `#define 名字 替换文本`  
    在该定义之后，程序中出现的所有在 #define 中定义的名字都将用相应的替换文本替换。  
    其中，名字与普通变量名的形式相同：它们都是以字母打头的字母和数字序列。  
    替换文本可以是任何字符序列，而不仅限于数字。  
    符号常量名通常用大写字母拼写，这样可以很容易与用小写字母拼写的变量名相区别。  
    `#define` 指令行的末尾没有分号。
11. 标准库提供的输入/输出模型非常简单：无论文本从何处输入，输出到何处，其输入/输出都是按照字符流的方式处理。  
    文本流是由多行字符构成的字符序列，而每行字符则由0个或多个字符组成，行末是一个换行符。  
    标准库负责使每个输入/输出流都能够遵守这一模型。  
    使用标准库的 C 语言程序员不必关心在程序之外这些行是如何表示的。  
    标准库保证输入文本流以行序列的形式出现，每一行均以换行符结束。  
    因此，统计行数等价于统计换行符的个数。
12. 字符在键盘、屏幕或其它的任何地方无论以什么形式表现，它在机器内部都是以位模式存储的。  
    char 类型专门用于存储这种字符型数据，当然任何整形也可以用于存储字符型数据。
13. C 语言的文件结束符定义为 EOF（end of file，文件结束）。  
    EOF 定义在头文件<stdio.h>中，是个整型数。
14. C 语言的 for 循环语句必须有一个循环体，可以使用空语句（只有一个分号）。
15. while循环和for循环在初始条件就不满足时，可能出现循环体一次都不执行的情况。
16. 单引号中的字符表示一个整型值，该值等于此字符在机器字符集中对应的数值，我们称之为字符常量。  
    字符常量不过是小的整型数的另一种写法而已。  
    例如，'A' 是一个字符常量：在ASCII字符集中其值为 65  
    当然，用 'A' 要比用 65 好，因为 'A' 的意义更清楚，且与特定的字符集无关。
17. 由 && 或 || 连接的表达式由左至右求值，并保证在求值过程中只要能够判断最终的结果为真或假，求值就立即终止。
18. 函数定义可以以任意次序出现在一个源文件或多个源文件中，但同一函数不能分割存放在多个文件中。
19. 通常把函数定义中圆括号内列表中出现的变量称为形式参数，而把函数调用中与形式参数对应的值称为实际参数。
20. 函数不一定都有返回值。  
    不带表达式的 return 语句将把控制权返回给调用者，但不返回有用的值。  
    主调函数也可以忽略函数返回的值。
21. 一般来说，main 函数返回值为 0 表示正常终止，返回值为 非0 表示出现异常情况或出错结束条件。
22. 函数声明（又称函数原型）必须与函数定义保持一致。  
    参数名不要求相同，事实上，函数声明的参数名是可选的，但合适的参数名能够起到很好的说明性作用。
23. 在 C 语言中，所有函数参数都是“通过值”传递的。  
    传递给被调用函数的参数值存放在临时变量中，而不是存放在原来的变量中。  
    形参是实参的副本。  
    当把数组名用作参数时，传递给函数的值是数组起始元素的位置或地址——它并不复制数组元素本身。
24. 字符数组是 C 语言中最常用的数组类型。
25. 不返回任何值的函数可以用 void 进行显式说明。  
    在 ANSI C 中，如果要声明空参数表，则必须使用关键字 void 进行显示声明。
26. C 语言以 '\0' 字符作为字符串结束标志。
27. 函数中的局部变量只在函数被调用时存在，在函数执行完毕退出时消失。
28. 外部变量必须定义在所有函数之外，且只能定义一次，定义后编译程序将为它分配存储单元。  
    在每个需要访问外部变量的函数中，必须声明相应的外部变量，此时说明其类型。  
    声明时可以用extern语句显式声明，也可以通过上下文隐式声明。  
    在源文件中，如果外部变量的定义出现在使用它的函数之前，那么在那个函数中就没有必要使用extern声明。  
    在通常的做法中，所有外部变量的定义都放在源文件的开始处，这样就可以省略extern声明。
29. “定义”表示创建变量或分配存储单元，而“声明”指的是说明变量的性质，但并不分配存储单元。

## 第 2 章  类型、运算符与表达式

1. 变量名是由字母和数字组成的序列，但其第一个字符必须为字母。  
    下划线 `_` 被看作是字母，通常用于命名较长的变量名，以提高其可读性。  
    由于例程的名字通常以下划线开头，因此变量名不要以下划线开头。  
    C 语言区分大小写，变量名使用小写字母。  
    关键字不能用作变量名。
2. int 通常代表特定机器中整数的自然长度。
3. 不带限定符的 char 类型对象是否带符号取决于具体机器，但可打印字符总是正值。
4. 数值常量：

    ```text
        int                 没有后缀
        long                l 或 L 结尾
        unsigned            u 或 U 结尾
        unsigned long       ul 或 UL 结尾
        double              没有后缀
        float               f 或 F 结尾
        long double         l 或 L 结尾

        十进制整型           没有前缀
        八进制整型           0 前缀
        十六进制整型         0x 或 0X 前缀
    ```

5. 一个字符常量是一个整数，书写时将一个字符括在单引号中。  
    字符在机器字符集中的数值就是字符常量的值。
6. 字符常量 '\0' 表示值为 0 的字符，也就是空字符（null）。  
    我们通常用 '\0' 的形式代替 0，以强调某些表达式的字符属性，但其数字值为 0
7. 常量表达式是仅仅只包含常量的表达式。  
    这种表达式在编译时求值，而不在运行时求值。  
    它可以出现在常量可以出现的任何位置。
8. 字符串常量也叫字符串字面值，是用双引号括起来的 0 个或多个字符组成的字符序列。  
    双引号不是字符串的一部分，它只用于限定字符串。  
    编译时可以将多个字符串常量连接起来。字符串常量的连接为将较长的字符串分散在多行提供了支持。
9. 从技术角度看，字符串常量就是字符数组。  
    字符串的内部表示使用一个空字符 '\0' 作为串的结尾。  
    因此，存储字符串的物理存储单元数比括在双引号中的字符数多一个。  
    C 语言对字符串的长度没有限制，但程序必须扫描完整个字符串后才能确定字符串的长度。
10. 我们应该搞清楚字符常量与仅包含一个字符的字符串之间的区别：'x' 与 "x" 是不同的。  
    前者是一个整数，其值是字母 x 在机器字符集中对应的数值（内部表示值）；  
    后者是一个包含一个字符以及一个结束符 '\0' 的字符数组。
11. 枚举常量是另外一种类型的常量。  
    枚举是一个常量整型值的列表。  
    在没有显式说明的情况下，enum 类型中第一个枚举名的值为 0，第二个为 1，依此类推。  
    如果只指定了部分枚举名的值，那么未指定的枚举名的值将依着最后一个指定值向后递增。  
    不同枚举中的名字必须互不相同。同一枚举中不同的名字可以具有相同的值。
12. 枚举为建立常量值与名字之间的关联提供了一种便利的方式。  
    相对于 #define 语句来说，它的优势在于常量值可以自动生成。  
    尽管可以声明 enum 类型的变量，但编译器不检查这种类型的变量中存储的值是否为该枚举的有效值。  
    不过，枚举变量提供这种检查，因此枚举比 #define 更具优势。  
    此外，调试程序可以以符号形式打印出枚举变量的值。
13. 默认情况下，外部变量与静态变量将被初始化为 0 。未经显式初始化的自动变量的值为未定义值（即无效值）。
14. 任何变量的声明都可以使用 const 限定符限定。  
    该限定符指定变量的值不能被修改。  
    对数组而言，const 限定符指定数组所有元素的值都不能被修改。  
    如果试图修改 const 限定符限定的值，其结果取决于具体的实现。
15. 取模运算符 % 不能应用于 float 或 double 类型。
16. 在有负操作数的情况下，整数除法截取的方向以及取模运算结果的符号取决于具体机器的实现，这和处理上溢或下溢的情况是一样的。
17. 类型转换：

    ```text
    * 自动转换是指把“比较窄的”操作数转换为“比较宽的”操作数，并且不丢失信息的转换。
    * 针对可能导致信息丢失的表达式，编译器可能会给出警告信息，比如把较长的整型值赋给较短的整型变量，把浮点型值赋值给整型变量，等等，但这些表达式并不非法。
    * C 语言没有指定 char 类型的变量是无符号变量还是带符号变量。
        当把一个 char 类型的值转换为 int 类型的值时，其结果有没有可能为负整数？
        对于不同的机器，其结果也不同，这反映了不同机器结构之间的区别。
    * C 语言的定义保证了机器的标准打印字符集中的字符不会是负值，因此，在表达式中这些字符总是正值。
    * 为了保证程序的可移植性，如果要在 char 类型的变量中存储非字符数据，最好指定 signed 或 unsigned 限定符。
    * 注意，表达式中 float 类型的操作数不会自动转换为 double 类型，这一点与最初的定义有所不同。
    * 使用 float 类型主要是为了在使用较大的数组时节省存储空间，有时也为了节省机器执行时间（双精度算术运算特别费时）。
    * 当表达式中包含 unsigned 类型的操作数时，转换规则要复杂一些。
        主要原因在于，带符号值和无符号值之间的比较运算是与机器相关的，因为它们取决于机器中不同整数类型的大小。
    * 赋值时也要进行类型转换。赋值运算符右边的值需要转换为左边变量的类型，左边变量的类型即赋值表达式结果的类型。
    * 当把较长的整数转换为较短的整数或 char 类型时，超出的高位部分将被丢弃。
    * 当把 float 类型转换为 int 类型时，小数部分将被截取掉；当把 double 类型转换为 float 类型时，是进行四舍五入还是截取取决于具体的实现。
    * 由于函数调用的参数是表达式，所以在把参数传递给函数时也可能进行类型转换。
    * 在任何表达式中都可以使用一个称为强制类型转换的一元运算符强制进行显式类型转换。
    * 注意，强制类型转换只是生成一个指定类型的 n 的值，n 本身的值并没有改变。
    ```

18. C 语言提供了自增运算符和自减运算符，自增和自减运算符只能作用于变量，类似于表达式 `(i+j)++` 是非法的。
19. C 语言提供了 6 个位操作运算符。  
    这些运算符只能作用于整型操作数，即只能作用于带符号或无符号 char、short、int、long 类型。
20. C 语言支持 “+=” 等赋值运算符的简写形式。  
    赋值表达式的类型是它的左操作数的类型，其值是赋值操作完成后的值。
21. 条件表达式（使用三元运算符 “ ? : ”）实际上就是一种表达式，它可以用在其它可以使用表达式的任何地方。  
    ` expr1 ? expr2 : expr3 `  
    expr2 与 expr3 中只能有一个表达式被计算。  
    如果 expr2 与 expr3 的类型不同，结果的类型将根据类型转换规则决定。
22. C 语言没有指定同一运算符中多个操作数的计算顺序（&&、||、?: 和 , 运算符除外）。  
    类似地，C 语言也没有指定函数各参数的求值顺序。
23. 在任何一种编程语言中，如果代码的执行结果与求值顺序相关，则都是不好的程序设计风格。  
    很自然，有必要了解哪些问题需要避免，但是，如果不知道这些问题在各种机器上是如何解决的，就最好不要尝试运用某种特殊的实现方式。

## 第 3 章  控制流

1. 用一对花括号 `{ }` 把一组声明和语句括在一起就构成了一个复合语句（也叫做程序块），复合语句在语法上等价于单条语句。
2. switch 语句是一种多路判定语句，它测试表达式是否与一些常量整数值中的某一个值匹配，并执行相应的分支动作。
3. 在 switch 语句中，case 的作用只是一个标号，因此，某个分支中的代码执行完后，程序将进入下一分支继续执行，除非在程序中显式地跳转。  
    跳出 switch 语句最常用的方法是使用 break 语句与 return 语句。  
    除了一个计算需要多个标号的情况外，应尽量减少从一个分支直接进入下一个分支执行这种用法，在不得不使用的情况下应该加上适当的程序注释。  
    作为一种良好的程序设计风格，在 switch 语句最后一个分支（即 default 分支）的后面也加上一个 break 语句。
4. 在 C 语言中，for 循环语句的循环变量和上限在循环体内可以修改，并且当循环因某种原因终止后循环变量 i 的值仍然保留。
5. 应该慎用逗号运算符。  
    被逗号分隔的一组表达式将按照从左到右的顺序进行求值，表达式右边的操作数的类型和值即为其结果的类型和值。
6. do-while 循环在循环体执行后测试终止条件，这样循环体至少被执行一次。
7. break 语句能使程序从 switch 语句或最内层循环中立即跳出。  
    continue 语句只用于循环语句，不用于 switch 语句。  
    在多层嵌套循环中，break 语句只能从最内层循环退出到上一级的循环。
8. C 语言提供了可随意滥用的 goto 语句以及标记跳转位置的标号。  
    从理论上将，goto 语句是没有必要的，实践中不使用 goto 语句也可以很容易地写出代码。  
    在某些场合下 goto 语句还是用得着的。最常见的用法是终止程序在某些深度嵌套的结构中的处理过程，例如一次跳出两层或多层循环。  
    标号的命名同变量命名的形式相同，标号的后面要紧跟一个冒号。  
    标号可以位于对应的 goto 语句所在函数的任何语句的前面。  
    标号的作用域是整个函数。  
    所有使用了 goto 语句的程序代码都能改写成不带 goto 语句的程序，但可能会增加一些额外的重复测试或变量。  
    建议尽可能少地使用 goto 语句。

## 第 4 章  函数与程序结构

1. 如果函数定义中省略了返回值类型，则默认为 int 类型。
2. 函数在源文件中出现的次序可以是任意的。  
    只要保证每一个函数不被分离到多个文件中，源程序就可以分成多个文件。
3. 被调用函数通过 return 语句向调用者返回值，return 语句的后面可以跟任何表达式。  
    在必要时，表达式将被转换为函数的返回值类型。  
    调用函数可以忽略返回值。  
    当 return 语句的后面没有表达式时，函数将不向调用者返回值。  
    如果某个函数从一个地方返回时有返回值，而从另一个地方返回时没有返回值，该函数并不非法，但可能是一种出问题的征兆。  
    在任何情况下，如果函数没有成功地返回一个值，则它的“值”肯定是无用的。
4. 默认情况下，外部变量与函数具有下列性质：通过同一个名字对外部变量的所有引用实际上都是引用同一个对象。  
    外部变量定义在函数之外，因此可以在许多函数中使用。  
    由于 C 语言不允许在一个函数中定义其它函数，因此函数本身是“外部的”。
5. 自动变量只能在函数内部使用，从其所在的函数被调用时变量开始存在，在函数退出时变量也将消失。  
    而外部变量是永久存在的，它们的值在一次函数调用到下一次函数调用之间保持不变。
6. 名字的作用域指的是程序中可以使用该名字的部分。  
    对于在函数开头声明的自动变量来说，其作用域是声明该变量名的函数。  
    不同函数中声明的具有相同名字的各个局部变量之间没有任何关系。  
    函数的参数也是这样的，实际上可以将它看作是局部变量。  
    外部变量或函数的作用域从声明它的地方开始，到其所在的文件的末尾结束。
7. 将外部变量的声明与定义严格区分开来很重要。  
    变量声明用于说明变量的属性（主要是变量的类型）。  
    而变量定义除此以外还将引起存储器的分配。  
    在一个源程序的所有源文件中，一个外部变量只能在某个文件中定义一次，而其它文件可以通过 extern 声明来访问它。  
    外部变量的初始化只能出现在其定义中。
8. 用 static 声明限定外部变量与函数，可以将其后声明的对象的作用域限定为被编译源文件的剩余部分。  
    通过 static 限定外部对象，可以达到隐藏外部对象的目的。  
    static 限定的对象不会和同一程序中其它文件中的相同名字相冲突。  
    static 也可用于声明内部变量。static 类型的内部变量是一种只能在某个特定函数中使用但一直占据存储空间的变量。
9. register 声明只适用于自动变量以及函数的形式参数。  
    每个函数中只有很少的变量可以保存在寄存器中，且只允许某些类型的变量。  
    但是，过量的寄存器声明并没有什么害处，这是因为编译器可以忽略过量的或不支持的寄存器变量声明。  
    无论寄存器变量实际上是不是存放在寄存器中，它的地址都是不能访问的。
10. 每次进入程序块时，在程序块内声明以及初始化的自动变量都将被初始化。  
    静态变量只在第一次进入程序块时被初始化一次。  
    自动变量（包括形式参数）可以隐藏同名的外部变量与函数。
11. 在一个好的程序设计风格中，应该避免出现变量名隐藏外部作用域中相同名字的情况，否则，很可能引起混乱和错误。
12. 在不进行显式初始化的情况下，外部变量和静态变量都将被初始化为 0，而自动变量和寄存器变量的初值则没有定义（即初值为无用的信息）。
13. 对于外部变量与静态变量来说，初始化表达式必须是常量表达式，且只初始化一次（从概念上讲是在程序开始执行前进行初始化）。  
    对于自动变量和寄存器变量，则在每次进入函数或程序块时都将被初始化。  
    对于自动变量和寄存器变量来说，初始化表达式可以不是常量表达式：表达式中可以包含任意在此表达式之前已经定义的值，包括函数调用。
14. 数组的初始化可以在声明的后面紧跟一个初始化表达式列表，初始化表达式列表用花括号括起来，各初始化表达式之间通过逗号分隔。  
    如果初始化表达式的个数比数组元素数少，则对外部变量、静态变量和自动变量来说，没有初始化表达式的元素将被初始化为 0  
    如果初始化表达式的个数比数组元素数多，则是错误的。
15. 字符数组可以用一个字符串来代替用花括号括起来并用逗号分隔的初始化表达式序列。
16. C 语言中的函数可以递归调用，即函数可以直接或间接调用自身。  
    函数递归调用自身时，每次调用都会得到一个与以前的自动变量集合不同的新的自动变量集合。  
    递归并不节省存储器的开销，因为递归调用过程中必须在某个地方维护一个存储处理值的栈。  
    递归的执行速度并不快，但递归代码比较紧凑，并且比相应的非递归代码更易于编写与理解。  
    在描述树等递归定义的数据结构时使用递归尤其方便。
17. 从概念上讲，预处理器是编译过程中单独执行的第一个步骤。  
    两个最常用的预处理器指令是：#include 指令（用于在编译期间把指定文件的内容包含进当前文件中）和 #define 指令（用任意字符序列替代一个标记）。
18. 如果文件名用引号引起来，则在源文件所在位置查找该文件；  
    如果在该位置没有找到文件，或者如果文件名是用尖括号 ` < > ` 括起来的，则将根据相应的规则查找该文件，这个规则同具体的实现有关。
19. 如果某个包含文件的内容发生了变化，那么所有依赖于该包含文件的源文件都必须重新编译。
20. 宏定义的形式如下：  
    ` #define 名字 替换文本 `  
    这是一种最简单的宏替换——后续所有出现名字记号的地方都将被替换为替换文本。  
    宏定义中也可以使用前面出现的宏定义。  
    宏定义也可以带参数，这样可以对不同的宏调用使用不同的替换文本。  
    宏定义的展开式要注意计算顺序和表达式副作用出错的情况。  
    如果在替换文本中，参数名以 # 作为前缀则结果将被扩展为由实际参数替换该参数的带引号的字符串。  
    预处理器运算符 ## 为宏扩展提供了一种连接实际参数的手段。
21. 条件编译为在编译过程中根据计算所得的条件值选择性地包含不同代码提供了一种手段。  
    条件编译的表达式中，如果名字已经定义，其值为 1，否则，其值为 0  
    可以使用条件编译避免多次重复包含同一文件。  
    C 语言专门定义了两个预处理语句 #ifdef 和 #ifndef 用来测试某个名字是否已经定义。

## 第 5 章  指针和数组

1. 指针是一种保存变量地址的变量。  
    ANSI C 使用类型 `void *` （指向 void 的指针）作为通用指针的类型。  
    指针只能指向某种特定类型的对象，也就是说，每个指针都必须指向某种特定的数据类型。  
    指向 void 类型的指针可以存放指向任何类型的指针，但它不能间接引用其自身。  
    由于指针也是变量，所以在程序中可以直接使用，而不必通过间接引用的方法使用。  
    指针也可以初始化。
2. 一元运算符 & 可用于取一个对象的地址。  
    地址运算符 & 只能应用于内存中的对象，即变量与数组元素。  
    它不能作用于表达式、常量或 register 类型的变量。
3. 一元运算符 `*` 是间接寻址或间接引用运算符。  
    当它作用于指针时，将访问指针所指向的对象。  
    如果指针 ip 指向整型变量 x，那么在 x 可以出现的任何上下文中都可以使用 *ip
4. 由于 C 语言是以传值的方式将参数值传递给被调用函数，因此，被调用函数不能直接修改主调函数中变量的值。  
    指针参数使得被调用函数能够访问和修改主调函数中对象的值。
5. 数组名所代表的是数组第一个元素的地址（即 a[0] 的地址）。

    ```text
    下面描述使用 int a[10]; 和 int *pa; 举例
    * 数组名和指针之间有一个不同之处：指针是一个变量，pa = a 和 pa++ 都是合法的；数组名不是变量，因此，类似于 a = pa 和 a++ 形式的语句是非法的。
    * 通过数组下标所能完成的任何操作都可以通过指针来实现。（一个通过数组和下标实现的表达式可等价地通过指针和偏移量实现。）
    * 一般来说，用指针编写的程序比用数组下标编写的程序执行速度快。
    * 如果 pa 指向数组中的某个特定元素，根据指针运算的定义，pa+1 将指向下一个元素，pa+i 将指向 pa 所指向数组元素之后的第 i 个元素，而 pa-i 将指向数组元素之前的第 i 个元素。
    * 如果指针 pa 指向 a[0]，那么： *(pa+1) == a[1];  *(pa+i) == a[i];
    * pa+n 表示指针 pa 当前指向的对象之后第 n 个对象的地址。无论指针 pa 指向的对象是何种类型，上述结论都成立。
    * 对数组元素 a[i] 的引用也可以写成 *(a+i) 这种形式。在计算数组元素 a[i] 的值时，C 语言实际上先将其转换为 *(a+i) 的形式，然后再进行求值，因此在程序中这两种形式是等价的。
    * 当把数组名传递给一个函数时，实际上传递的是该数组第一个元素的地址。在被调用函数中，该参数是一个局部变量。
    ```

6. 指针的算术运算：

    ```text
    * C 语言保证，0 永远不是有效的数据地址，因此，返回值 0 可用来表示发生了异常事件。
    * C 语言中指针的算术运算具有一致性：所有的指针运算都会自动考虑它所指向的对象长度。
    * 指针与整数之间不能相互转换，但 0 是唯一的例外：常量 0 可以赋值给指针，指针也可以和常量 0 进行比较。
        任何指针与 0 进行相等或不等的比较运算都有意义。
    * 首先，指向相同数组的两个指针可以进行比较运算。
        但是，指向不同数组的元素指针之间的算术或比较运算没有定义。
        （这里有一个特例：指针的算术运算中可使用数组最后一个元素的下一个元素的地址。）
    * 其次，指针可以和整数进行相加或相减运算。
        指针的减法运算也是有意义的：如果 p 和 q 指向相同数组中的元素，且 p<q ，那么 q-p+1 就是位于 p 和 q 指向的元素之间的元素的数目。
    ```

    有效的指针运算包括相同类型指针之间的赋值运算；指针同整数之间的加法或减法运算；指向相同数组中元素的两个指针间的减法或比较运算；将指针赋值为 0 或指针与 0 之间的比较运算。  
    其它所有形式的指针运算都是非法的，例如两个指针间的加法、乘法、除法、移位或屏蔽运算；指针同 float 或 double 类型之间的加法运算；不经强制类型转换而直接将指向一种类型对象的指针赋值给指向另一种类型对象的指针的运算（两个指针之一是 `void *` 类型的情况除外）。
7. 字符串：
    字符串常量可以通过一个指向其第一个元素的指针访问。
    C 语言没有提供将整个字符串作为一个整体进行处理的运算符。

    ```text
        下面两个定义之间有很大的差别：
            char amessage[] = "now is the time"; /* 定义一个数组 */
            char *pmessage = "now is the time";  /* 定义一个指针 */
        上述声明中，amessage 是一个仅仅足以存放初始化字符串以及空字符 '\0' 的一维数组。
            数组中的单个字符可以进行修改但 amessage 始终指向同一个存储位置。
        pmessage 是一个指针，其初值指向一个字符串常量，之后它可以被修改以指向其它地址，但如果试图修改字符串的内容，结果是没有定义的。
    ```

8. 标准进栈和出栈操作：

    ```c
        *p++ = val; /* 将val压入栈 */
        val = *--p; /* 将栈顶元素弹出到val中 */
    ```

9. 在 C 语言中，二维数组实际上是一种特殊的一维数组，它的每个元素也是一个一维数组。  
    数组元素按行存储，因此，当按存储顺序访问数组时，最右边的数组下标（即列）变化的最快。  
    数组可以用花括号括起来的初值表进行初始化，二维数组的每一行由相应的子列表进行初始化。  
    如果将二维数组作为参数传递给函数，那么在函数的参数声明中必须指明数组的列数。  
    一般来说，除数组的第一维（下标）可以不指定大小外，其余各维都必须明确指定大小。
10. 指针数组的一个重要优点在于，数组的每一行长度可以不同。
11. 调用主函数 main 时，它带有两个参数：argc 用于参数计数，argv 是一个指向字符串数组的指针，其中每个字符串对应一个参数。  
    按照 C 语言的约定，argv[0] 的值是启动该程序的程序名，因此 argc 的值至少为 1  
    ANSI 标准要求 argv[argc] 的值必须为一空指针。
12. 在 C 语言中，函数本身不是变量，但可以定义指向函数的指针。这种类型的指针可以被赋值、存放在数组中、传递给函数以及作为函数的返回值等等。
13. 任何类型的指针都可以转换为 `void *` 类型，并且在将它转换回原来的类型时不会丢失信息。

## 第 6 章  结构

1. 结构是一个或多个变量的集合，这些变量可能为不同的类型，为了处理的方便而将这些变量组织在一个名字之下。
2. ANSI C 规定结构可以拷贝、赋值、传递给函数，函数也可以返回结构类型的返回值。
3. 使用 struct 引入结构声明。  
    struct 后面的名字是可选的，称为结构标记。  
    结构标记用于为结构命名，可以用它声明结构变量。  
    结构中定义的变量称为成员。  
    结构成员使用结构成员运算符 “.” 访问  
    结构可以嵌套。
4. 结构的合法操作只有几种：作为一个整体复制和赋值，通过 & 运算符取地址，访问其成员。  
    复制和赋值包括向函数传递参数以及从函数返回值。  
    结构之间不可以进行比较。  
    可以用一个常量成员值列表初始化结构，自动结构也可以通过赋值进行初始化。
5. 参数名和结构成员同名不会引起冲突。事实上，使用重名可以强调两者之间的关系。
6. 结构类型参数也是通过值传递的。  
    如果传递给函数的结构很大，使用指针方式的效率通常比复制整个结构的效率要高。
7. 结构指针可以使用 “->” 运算符访问结构成员。  
    运算符 . 和 -> 都是从左至右结合的。
8. C 语言提供了一个编译时一元运算符 sizeof，它可用来计算任一对象的长度。
9. 数组的长度在编译时已经完全确定，它等于数组项的长度乘以项数。
10. 条件编译语句 #if 中不能使用 sizeof，因为预处理器不对类型名进行分析。  
    但预处理器并不计算 #define 语句中的表达式，因此，在 #define 中使用 sizeof 是合法的。
11. 指针之间的加法运算是非法的，但减法运算是合法的。
12. C 语言的定义保证数组末尾之后的第一个元素的指针算术运算可以正确执行。
13. 千万不要认为结构的长度等于各成员长度的和。因为不同的对象有不同的对齐要求，所以，结构中可能会出现未命名的“空穴”（hole）。  
    使用 sizeof 运算符可以返回正确的对象长度。
14. C 语言提供了一个称为 typedef 的功能，它用来建立新的数据类型名。  
    从任何意义上讲，typedef 声明并没有创建一个新类型，它只是为某个已存在的类型增加了一个新的名称而已。  
    typedef 声明也没有增加任何新的语义：通过这种方式声明的变量与通过普通声明方式声明的变量具有完全相同的属性。  
    实际上，typedef 类似于 #define 语句，但由于 typedef 是由编译器解释的，因此它的文本替换功能要超过预处理器的能力。  
    typedef 可以使程序参数化，以提高程序的可移植性。如果 typedef 声明的数据类型同机器有关，那么，当程序移植到其它机器上时，只需改变 typedef 类型定义就可以了。  
    typedef 的第二个作用是为程序提供更好的说明性——Treeptr 类型显然比一个声明为指向复杂结构的指针更容易让人理解。

    ```text
        typedef char *String;
    将 String 定义为与 char * 或字符指针同义，此后，便可以在类型声明和类型转换中使用 String
    ```

15. 联合是可以合法地保存多种数据类型中任何一种类型的对象。  
    编译器负责跟踪对象的长度和对齐要求。  
    联合读取的类型必须是最近一次存入的类型，程序员负责跟踪当前保存在联合中的类型。  
    如果保存的类型与读取的类型不一致，其结果取决于具体的实现。  
    实际上，联合就是一个结构，它的所有成员相对于基地址的偏移量都为 0，此结构空间要大到足够容纳最“宽”的成员，并且，其对齐方式要适合于联合中所有类型的成员。  
    联合的访问方式与结构相同：联合名.成员 、 联合指针->成员。  
    对联合允许的操作与对结构允许的操作相同：作为一个整体单元进行赋值、复制、取地址及访问其中一个成员。  
    联合只能用其第一个成员类型的值进行初始化。
16. C 语言提供了 “位字段”(bit-field)：直接定义和访问一个字中的位字段的能力。  
    字是单个的存储单元，它同具体的实现有关。  
    字段的所有属性几乎都同具体的实现有关。  
    某些机器上字段的分配是从字的左端至右端进行的，而某些机器上则相反。依赖于这些因素的程序是不可移植的。

## 第 7 章  输入与输出

1. 输入 / 输出功能并不是 C 语言本身的组成部分。
2. 文本流由一系列行组成，每一行的结尾是一个换行符。  
    如果系统没有遵循这种模式，则标准库将通过一些措施使得该系统适应这种模式。  
    例如，标准库可以在输入端将回车符和换行符都转换为换行符，而在输出端进行反向转换。
3. getchar 函数在每次被调用时返回下一个输入字符。  
    若遇到文件结尾，则返回 EOF  
    putchar(c) 将字符 c 送至标准输出上，在默认情况下，标准输出为屏幕显式。  
    如果没有发生错误，则函数 putchar 将返回输出的字符；如果发生了错误，则返回 EOF
4. 程序中应该使用 EOF 来测试文件是否结束，这样才能保证程序同 EOF 的特定值无关。
5. 标准库的许多“函数”都是用宏实现，这样就避免了对每个字符都进行函数调用的开销。
6. 无论 `<ctype.h>` 中的函数在给定的机器上是如何实现的，使用这些函数的程序都不必了解字符集的知识。
7. printf 格式字符串包含两种类型的对象：普通字符和转换说明。  
    每个转换说明都由一个百分号字符（即 %）开始，并以一个转换字符结束。  
    函数 printf 使用第一个参数判断后面参数的个数及类型。  
    如果参数的个数不够或者类型错误，则将得到错误的结果。
8. C 语言用省略号表示参数表中参数的数量和类型是可变的。  
    省略号只能出现在参数表的尾部。
9. 标准头文件 <stdarg.h> 中包含一组宏定义，它们对如何遍历参数表进行了定义。  
    该头文件的实现因不同的机器而不同，但提供的接口是一致的。
10. 当 scanf 函数扫描完其格式串，或者碰到某些输入无法与格式控制说明匹配的情况时，该函数将终止，同时，成功匹配并赋值的输入项的个数将作为函数返回值。  
    返回值可以用来确定已匹配的输入项的个数。  
    如果到达文件的结尾，该函数将返回 EOF  
    返回 EOF 与 0 是不同的，0 表示下一个输入字符与格式串中的第一个格式说明不匹配。  
    下一次调用 scanf 函数将从上一次转换的最后一个字符的下一个字符开始继续搜索。  
    如果转换说明中有赋值禁止字符 `*` ，则跳过该输入字段，不进行赋值。  
    输入字段定义为一个不包括空白符的字符串，其边界定义为到下一个空白符或到达指定的字段宽度。  
    这表明 scanf 函数将越过行边界读取输入，因为换行符也是空白符。  
    （空白符包括空格符、横向制表符、换行符、回车符、纵向制表符以及换页符）。  
    scanf 和 sscanf 函数除格式参数外的其它所有参数都必须是指针。
11. `FILE *` 称为文件指针，它指向一个包含文件信息的结构，这些信息包括：缓冲区的位置、缓冲区中当前字符的位置、文件的读或写状态、是否出错或是否已经到达文件结尾等等。  
    FILE 是通过 typedef 定义的类型名。
12. fopen 的访问模式：

    ```text
    r       读
    w       写
    a       追加
    b       二进制模式
    ```

    如果打开一个不存在的文件用于写或追加，该文件将被创建（如果可能的话）。  
    当以写方式打开一个已存在的文件时，该文件原来的内容将被覆盖。  
    如果以追加方式打开一个文件，则该文件原来的内容将保留不变。  
    读一个不存在的文件会导致错误。  
    其它一些操作也可能导致错误，比如试图读取一个无读取权限的文件。  
    如果发生错误，fopen 将返回 NULL
13. getc 如果到达文件尾或出现错误，将返回 EOF  
    putc 将返回写入的字符。如果发生错误，则返回 EOF  
    getc 和 putc 是宏而不是函数  
    getchar 和 putchar 也是宏
14. 启动一个 C 语言程序时，操作系统环境负责打开 3 个文件，并将这 3 个文件的指针提供给该程序。  
    stdin       标准输入  
    stdout      标准输出  
    stderr      标准错误  
    这 3 个文件指针（`FILE *` 类型对象）是常量而非变量。
15. 当程序正常终止时，程序会自动为每个打开的文件调用 fclose 函数。  
    fclose 函数将刷新缓冲区（将缓冲区内容写入文件）。
16. 按照惯例，返回值 0 表示一切正常，而非 0 返回值通常表示出现了异常情况。
17. exit 为每个已打开的输出文件调用 fclose 函数。  
    在 main 函数中，语句 return expr; 等价于 exit(expr);
18. fgets 函数读取的行将以 '\0' 结尾保存到数组中。  
    如果遇到了文件结尾或发生了错误，则返回 NULL  
    fputs 函数如果发生错误，将返回 EOF，否则返回一个非负值。
19. gets 函数在读取字符串时将删除结尾的换行符（'\n'），而 puts 函数在写入字符串时将在结尾添加一个换行符。
20. ungetc 函数将字符写回到文件中。  
    如果执行成功，则返回写回字符，否则返回 EOF  
    每个文件只能接收一个写回字符。
21. malloc 函数分配成功时，返回一个指针，该指针指向 n 字节长度的未初始化的存储空间，否则返回 NULL  
    calloc 函数分配成功时，返回一个指针，该指针指向足以容纳 n 个指定长度的对象组成的数组，否则返回 NULL。该存储空间被初始化为 0  
    根据请求的对象类型，malloc 或 calloc 函数返回的指针满足正确的对齐要求。  
    存储空间的释放顺序没有什么限制，但是，如果释放一个不是通过 malloc 或 calloc 函数得到的指针所指向的存储空间，将是一个很严重的错误。  
    使用已经释放的存储空间同样是错误的。

## 第 8 章  UNIX 系统接口

1. ANSI C 标准函数库是以UNIX系统为基础建立起来的。
2. 在任何特定的系统中，标准库函数的实现必须通过宿主系统提供的功能来实现。
3. 系统负责维护已打开文件的所有信息，用户程序只能通过文件描述符（Windows系统为文件句柄）引用文件。
4. 当命令解释程序（shell）运行一个程序的时候，它将打开 3 个文件，对应的文件描述符分别为 0、1、2，依次表示标准输入、标准输出和标准错误。
5. 标准库中的函数名称以下划线开头，因此一般不会与用户程序中的名字冲突。  
    所有的标准库函数都遵循该约定。
6. 许多程序并不是“系统程序”，它们仅仅使用由操作系统维护的信息。  
    对于这样的程序，很重要的一点是，信息的表示仅出现在标准头文件中，使用它们的程序只需要在文件中包含这些头文件即可，而不需要包含相应的声明。  
    有可能为与系统相关的对象创建一个与系统无关的接口。

## 附录A

1. 本手册描述的 C 语言是1988年10月31日提交给 ANSI的草案。（接近于 ANSI C - 1989）
2. C 语言中共有6类记号：标识符、关键字、常量、字符串字面值、运算符和其它分隔符。
3. 注释以字符 `/*` 开始，以 `*/` 结束。  
    注释不能够嵌套，也不能够出现在字符串字面值或字符字面值中。
4. 标识符是由字母和数字构成的序列。  
    第一个字符必须是字母，下划线 “_” 也被看成是字母。  
    大写字母和小写字母是不同的。  
    标识符可以为任意长度。  
    对于内部标识符来说，至少前31个字母是有效的，在某些实现中，有效的字符数可能更多。  
    内部标识符包括预处理器的宏名和其它所有没有外部连接的名字。  
    带有外部连接的标识符的限制更严格一些，实现可能只认为这些标识符的前6个字符是有效的，而且有可能忽略大小写的不同。
5. 字符串字面值不包含换行符和双引号字符，但可以用与字符常量相同的转义字符序列表示它们。
6. 对象有时也称为变量，它是一个存储位置。  
    对它的解释依赖于两个主要属性：存储类和类型。  
    存储类决定了与该标识对象相关联的存储区域的生存期，类型决定了标识对象中值的含义。  
    存储类分为两类：自动存储类（automatic）和静态存储类（static）  
    声明对象时使用的一些关键字和声明的上下文共同决定了对象的存储类。  
    自动存储类对象对于一个程序块来说是局部的，在退出程序块时该对象将消失。  
    声明为 register 的对象也是自动存储类对象。  
    静态对象在退出和再进入函数或程序块时其值将保持不变。  
    在所有程序块外部声明且与函数定义在同一级的对象总是静态的。
7. 以关键字 unsigned 声明的无符号整数遵守算术模 2^n 的规则。  
    其中，n 是表示相应整数的二进制位数，这样，对无符号数的算术运算永远不会溢出。
8. 枚举是一个具有整型值的特殊的类型。与每个枚举相关联的是一个命名常量的集合。
9. 整型对象可以显式地转换为指针。  
    这种映射总是将一个足够宽的从指针转换来的整数转换为同一个指针，其它情况依赖于具体的实现。
10. “对齐”的概念依赖于具体的实现，但 char 类型的对象具有最小的对齐限制。
11. 指针可以转换为 `void *` 类型，并可原封不动地转换回来。
12. 对于某类型 T ，如果某表达式或子表达式的类型为 “ T 类型的数组”，则此表达式的值是指向数组中第一个对象的指针，并且此表达式的类型将被转换为 “指向 T 类型的指针”。  
    如果此表达式是一元运算符 & 或 sizeof ，则不会进行转换。
13. sizeof 应用于 char 类型时，其结果值为 1；将它应用于数组时，其值为数组中字节的总数。
14. `(a/b) * b + a % b` 等于 a 永远成立。
15. && 和 || 确保从左到右的求值次序。
16. 如果没有指定存储类说明符，则将按照下列规则进行：  
    在函数内部声明的对象被认为是 auto 类型；  
    在函数内部声明的函数被认为是 extern 类型；  
    在函数外部声明的对象与函数将被认为是 static 类型，且具有外部连接。
17. 枚举符表中的标识符声明为 int 类型的常量，它们可以用在常量可以出现的任何地方。  
    同一作用域中的各枚举符的名字必须互不相同，也不能与普通变量名相同，但其值可以相同。
18. 根据数组下标运算的定义，E1[E2] 等价于 `*(E1+E2)`

## 附录B

1. 在7位ASCII字符集中，可打印字符是从0x20（' '）到0x7E（'~'）之间的字符；控制字符是从0（NULL）到0x1F（US）之间的字符以及字符0x7F（DEL）
