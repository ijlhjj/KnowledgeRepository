0、Throwable类是所有异常的基类：
    Error和Exception是Throwable的两个直接子类；
    Error类描述系统内部错误和资源耗尽问题，你不应该抛出这类异常。如果出现这类错误，除了通知用户，并尽力妥善地终止程序之外，你几乎无能为力。这种情况很少出现；
    Exception是我们主要关注的异常类型，它又分为RuntimeException和其他异常；
    一般规则是：有编程错误导致的异常属于RuntimeException；如果程序本身没有问题，但由于I/O错误之类的问题导致的异常属于其他异常；
    如果出现RuntimeException异常，那么一定是你的问题；

1、在理想世界里，用户输入数据的格式永远都是正确的，选择打开的文件也一定存在，代码永远不会出现 bug 。
2、程序出现错误时，至少应该做到以下几点：
    向用户通知错误；
    保存所有工作；
    允许用户妥善地退出程序；
3、用户期望在出现错误时，程序能够采取合理的行为。如果由于出现错误而导致一个操作无法完成，程序应该返回到一种安全状态，并允许用户执行其他的命令；或者允许用户保存所有工作，并妥善地终止程序。
4、程序中可能出现的错误和问题：
    用户输入错误；
    设备错误；
    物理限制；
    代码错误；
5、异常有自己的语法和一个特殊的继承层次结构。
6、Java语言规范将派生于Error类或RuntimeException类的所有异常称为非检查型异常（unchecked），所有其他异常称为检查型异常（checked）。
    编译器将检查你是否为所有的检查型异常提供了异常处理器。
7、方法不仅需要告诉编译器将要返回什么值，还要告诉编译器有可能发生什么错误。
8、任何一个抛出异常的方法都有可能是一个死亡陷阱。如果没有处理器捕获这个异常，当前的执行线程就会终止。
    如果发生了某个异常，但没有在任何地方捕获这个异常，程序就会终止，并在控制台上打印一个消息，其中包括这个异常的类型和一个栈轨迹。
9、不需要声明Java的内部错误，即从Error继承的异常。任何代码都有可能抛出那些异常，而我们对此完全无法控制。
    类似地，也不应该声明从RuntimeException继承的那些非检查型异常。
10、一个方法必须声明所有可能抛出的检查型异常，而非检查型异常要么在你的控制之外（Error），要么是由从一开始就应该避免的情况导致的（RuntimeException）。
11、如果在子类中覆盖了超类的一个方法，子类方法中声明的检查型异常不能比超类方法中声明的异常更通用（子类方法可以抛出更特定的异常，或者根本不抛出任何异常）。
    特别需要说明的是，如果超类方法没有抛出任何检查型异常，子类也不能抛出任何检查型异常。
12、如果类中的一个方法声明它会抛出一个异常，而这个异常是某个特定类的实例，那么这个方法抛出的异常可能属于这个类，也可能属于这个类的任意一个子类。
13、一旦方法抛出了异常，这个方法就不会返回到调用者。也就是说，你不必操心建立一个默认的返回值或错误码。
14、自定义异常类应该包含两个构造器，一个是默认的构造器，另一个是包含详细描述信息的构造器。
15、编译器严格地执行throws说明符。如果调用了一个抛出检查型异常的方法，就必须处理这个异常，或者继续传递这个异常。
    一般经验是，要捕获那些你知道如何处理的异常，而继续传播那些你不知道怎样处理的异常。
16、捕获多个异常时，异常变量隐含为final变量。
    捕获多个异常不仅会让你的代码看起来更简单，还会更高效。
17、在catch中转换异常类型时，把原始异常设置为新异常的“原因”是比较合理的做法，这样不会丢失原始异常的细节信息。
18、try语句可以只有finally子句，而没有catch子句。
19、不管是否捕获到异常，finally子句中的代码都会执行。
20、当finally子句包含return语句时，有可能产生意想不到的结果。
    假设由return语句从try语句块中间退出。在方法返回前，会执行finally子句块。如果finally块也有一个return语句，这个返回值将会屏蔽原来的返回值。
21、finally子句的体要用于清理资源。不要把改变控制流的语句（return，throw，break，continue）放在finally子句中。
22、try-with-resources语句：
    try-with-resources语句适用于所有实现了AutoCloseable接口的类对象；
    只要需要关闭资源，就要尽可能使用try-with-resources语句；
    如果try块抛出一个异常，而且close方法也抛出一个异常，这就会带来一个难题；
        try-with-resources语句可以很好地处理这种情况；
        如果用常规方式手动编程，需要两个嵌套的try/finally语句；
        原来的异常会重新抛出，而close方法抛出的所有异常会“被抑制”；
        这些异常将被自动捕获，并由addSuppressed方法添加到原来的异常中去；
        如果对这些异常感兴趣，可以调用getSuppressed方法，它会生成一个数组，其中包含从close方法抛出的被抑制的异常；
    在Java9中，可以在try首部提供之前声明的事实最终变量；
    try-with-resources语句自身也可以有catch子句，甚至还可以有一个finally子句。这些子句会在关闭资源之后执行；

23、使用异常的建议：
    异常处理不能代替简单的测试；
    不要过分地细化异常；
    合理利用异常层次结构；
    不要压制异常；
    在检测错误时，“苛刻”要比放任更好；
    不要羞于传递异常；
    使用标准方法报告null指针和越界异常；
    不要向最终用户显式栈轨迹；
    异常应该“早抛出，晚捕获”；
24、与完成简单的测试相比，捕获异常所花费的时间大大超过了前者，因此使用异常的基本规则是：只在异常情况下使用异常。
25、Java采用的异常处理机制，是将异常处理的程序代码集中在一起，与正常的程序代码分开，使得程序简洁、优雅，并易于维护。
26、检查型异常本质上开销较大，不要为逻辑错误抛出这些异常。
    反射库的做法就不正确。调用者经常需要捕获那些他们知道不可能发生的异常。     ？
27、调用一个方法时，如果提供了非法的参数，返回一个虚拟值是不是比抛出一个异常更好？
    例如，当栈为空时，Stack.pop是该返回null，还是要抛出一个异常？我们认为：最好在出错的地方抛出一个EmptyStackException异常，这要好于以后出现一个NullPointerException异常。
28、应该将栈轨迹记入日志，以便以后获取，而只向用户显示一个总结消息。
