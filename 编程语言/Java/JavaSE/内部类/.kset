1、内部类是定义在另一个类中的类。
    使用内部类主要有两个原因：
        内部类可以对同一个包中的其他类隐藏；
        内部类方法可以访问定义这些方法的作用域中的数据，包括原本私有的数据；

2、内部类原先对于简洁地实现回调非常重要，不过如今lambda表达式在这方面可以做的更好。但内部类对于构建代码还是很有用的。
3、内部类的对象会有一个隐式引用，指向实例化这个对象的外部类对象。通过这个指针，它可以访问外部对象的全部状态。
    外部类的引用在构造器中设置。编译器会修改所有的内部类构造器，添加一个对应外部类引用的参数。
    在内部类使用 OuterClass.this 表示外部类引用。
    在Java中，静态内部类没有这个附加的指针，所以Java的静态内部类就相当于C++中的嵌套类。
4、内部类的语法很复杂。
5、内部类技术在设计合作类集合时很有用。
6、只有内部类可以是私有的，而常规类可以有包可见性或公共可见性。
7、内部类中声明的所有静态字段都必须是final，并初始化为一个编译时常量。如果这个字段不是一个常量，就可能不唯一。
8、内部类不能有static方法，Java语言规范对这个限制没有做任何解释。
9、由于内部类拥有更大的访问权限，所以天生就比常规类功能更加强大。
10、在Java11之前，内部类纯粹是一种编译器现象，虚拟机对它们并没有任何特别的了解。在Java11中，虚拟机了解类之间的嵌套关系，不再生成访问方法。
11、局部内部类：
    声明局部类时不能有访问修饰符（即public或private）；
    局部类的作用域总是限定在声明这个局部类的块中；
    局部类有一个很大的优势，即对外部世界完全隐藏；
    局部类不仅能够访问外部类的字段，还可以访问局部变量！不过，那些局部变量必须是事实最终变量；
    
12、匿名内部类：
    匿名内部类不能有构造器，但可以提供一个对象初始化块；

13、如果将一个匿名类实例存储在用var定义的一个变量中，这个变量会了解增加的方法或字段。这是一个“不可指示的”类型，即无法用Java语法表示的一个类型。不过，编译器理解这个类型，可以为变量设置这个类型。（Java核心技术12th上P276）
14、“双括号初始化”利用了内部类语法，在实际中这个技巧很少使用。
    invite( new ArrayList<String>() {{ add("Harry"); add("Tony"); }} )
15、建立一个与超类大体类似的匿名子类通常会很方便。不过，要特别当心 equals 方法，对于匿名子类以下测试会失败：
    if (getClass() != other.getClass()) return false;
16、只要内部类不需要访问外部类对象，就应该使用静态内部类。有些程序员用嵌套类表示静态内部类。
    与常规内部类不同，静态内部类可以有静态字段和方法；
17、在接口中声明的内部类自动是static和public 。
18、类中声明的接口、记录和枚举都自动为static 。
