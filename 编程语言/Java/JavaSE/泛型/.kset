0、Java泛型机制：
    泛型并不是Java语言特性的一部分。它是在JDK5中才添加的一种折中的实现参数化类型的机制。
    泛型程序设计意味着编写的代码可以对多种不同类型的对象重用。
    在Java中增加泛型类之前，泛型程序设计是用继承实现的。泛型提供了一个更好的解决方案：类型参数。
    凭经验来说，只有原本涉及大量通用类型的强制类型转换的代码才会因使用类型参数而受益。
    设计Java泛型时，主要目标是允许泛型代码和遗留代码之间能够互操作。
    常见的做法是类型变量使用大写字母，而且很简短。
        Java类库使用变量E表示集合的元素类型，K和V分别表示键和值的类型，T、U、S表示任意类型。
    一般来讲，无论S与T有什么关系，Pair<S> 与 Pair<T> 都没有任何关系。
    泛型类型与Java数组之间的一个重要区别：数组有特别的保护。

1、泛型类：
    泛型类就是有一个或多个类型变量的类；
    类型变量在整个类定义中用于指定方法的返回类型以及字段和局部变量的类型；
    泛型类相当于普通类的工厂；
    类型Pair<Manager>是 Pair<? extends Employee> 的子类型；
    Class类是泛型类。例如，String.class 实际上是一个 Class<String> 类的对象（事实上，也是唯一的对象）；

2、泛型方法：
    可以在泛型类中定义泛型方法，也可以在普通类中定义泛型方法；
    泛型方法的类型变量放在修饰符的后面，并在返回类型的前面；
    在大多数情况下，方法调用中可以省略类型参数，编译器有足够的信息推断出你想要的方法；
    几乎在所有情况下，泛型方法的类型推导都能正常工作。偶尔，编译器也会提示错误，此时你就需要解译错误报告；
    如果想知道编译器对一个泛型方法调用最终推断出哪种类型，Peter von der Ahe 推荐了这样一个窍门：故意引入一个错误，然后研究所得到的错误消息；

3、泛型的限制与局限性：
    * 不能用基本类型实例化类型参数；
        不能用基本类型代替类型参数。因此，没有Pair<double>，只有Pair<Double>
        当然，其原因就在于类型擦除。擦除之后，Pair类含有Object类型的字段，而Object不能存储double值。
        这样做与Java语言中基本类型的独立状态相一致。
    * 运行时类型查询只适用于原始类型；
        虚拟机中的对象总是有一个特定的非泛型类型。因此，所有的类型查询只生成原始类型。
        同样的道理，getClass方法总是返回原始类型。
    * 不能创建参数化类型的数组；
        尽管能够通过数组存储的检查，但仍然会导致一个类型错误。出于这个原因，不允许创建参数化类型的数组。
        需要说明的是，只是不允许创建这些数组，而声明类型为 Pair<String>[] 的变量仍是合法的。不过不能用 new Pair<String>[10] 初始化这个变量。
        如果需要收集参数化类型对象，可以直接使用 ArrayList<Pair<String>> ，很安全也很有效。
    * Varargs警告；
        Java不支持泛型类型的数组。
    * 不能实例化类型变量；
        在Java8之后，最好的解决办法是让调用者提供一个构造器表达式。
    * 不能构造泛型数组；
        就像不能实例化泛型实例一样，也不能实例化数组，不过原因有所不同。
        构造器表达式 String::new 指示一个函数，给定所需的长度，会构造一个指定长度的String数组。
    * 泛型类的静态上下文中类型变量无效；
        不能在静态字段或方法中引用类型变量。
        带有类型变量的静态字段和方法是完全非法的。
    * 不能抛出或捕获泛型类的实例；
        既不能抛出也不能捕获泛型类的对象。实际上，甚至泛型类扩展Throwable都是不合法的。
        不过，在异常规范中使用类型变量是允许的。
    * 可以取消对检查型异常的检查；
        Java异常处理的一个基本原则是，必须为所有检查型异常提供一个处理器。不过可以利用泛型取消这个机制。
        通过使用泛型类、擦除和 @SuppressWarnings 注解，我们就能消除Java类型系统的一个基本限制。
    * 注意擦除后的冲突；
        泛型规范还指出了另外一个规则：“为了指出擦除转换，我们要施加一个限制：倘若两个接口类型是同一接口的不同参数化，一个类或类型变量就不能同时作为这两个接口类型的子类。”
        这一限制与类型擦除的关系并不十分明显。其原因非常微妙，这有可能与合成的桥方法产生冲突。

4、泛型类型限定：
    类型变量T可以添加限定类型表示T应该是限定类型的子类型，T和限定类型可以是类，也可以是接口。
    按照Java继承机制，可以根据需要拥有多个接口超类型，但最多有一个限定可以是类。如果有一个类作为限定，它必须是限定列表中的第一个限定。
    限定类型用 “&” 分隔，而逗号用来分隔类型变量。

5、对于Java泛型的转换，需要记住以下几点：
    虚拟机中没有泛型，只有普通的类和方法；
    所有的类型参数都会替换为它们的限定类型；
    会合成桥方法来保持多态；
    为保持类型安全性，必要时会插入强制类型转换；

6、泛型通配符：
    Java的设计者发明了一种巧妙的（但很安全的）“逃生出口”：通配符类型。
    通配符类型非常抽象，不过，利用通配符类型，构建类库的程序员可以编写出尽可能灵活的方法。
    直观地讲，带有超类型限定的通配符允许你写入一个泛型对象，而带有子类型限定的通配符允许你读取一个泛型对象。
    如果你是一名库程序员，一定要熟悉通配符，否则，就会受到用户的责备，他们要在代码中随机地添加强制类型转换直至代码能够编译。
    甚至还可以使用根本无限定的通配符，例如：Pair<?> 。初看起来，这好像与原始的Pair类型一样。实际上，这两种类型有很大的不同。
        Pair<?> 和 Pair 本质的不同在于：你可以用任意Object对象调用原始Pair类的setFirst方法。
    通配符捕获只有在非常有限的情况下是合法的。
        编译器必须能够保证通配符表示单个确定的类型。
        例如，ArrayList<Pair<T>> 中的T绝对不能捕获 ArrayList<Pair<?>> 中的通配符。
        数组列表可能包含两个 Pair<?> ，其中的 ？ 可能分别有不同的类型。

7、泛型类型擦除：
    虚拟机没有泛型类型对象——所有对象都属于普通类。
    无论何时定义一个泛型类型，都会自动提供一个相应的原始类型。这个原始类型的名字就是去掉类型参数后的泛型类型名。类型变量会被擦除，并替换为其限定类型。
    泛型类型只在静态类型检查时期存在，在这之后，程序中所有的泛型类型都会被擦除，并替换为它们的非泛型上界。
    出于兼容性考虑，编译器在完成检查后将所有类型化数组列表转换成原始ArrayList对象。在程序运行时，所有的数组列表都是一样的，即虚拟机中没有类型参数。
    原始类型用第一个限定来替换类型变量，或者，如果没有给定限定，就替换为Object
        class Interval<T extends Serializable & Comparable> 中原始类型会用 Serializable 替换 T ，而且编译器会在必要时插入转换为 Comparable 的强制类型转换。
        为了提高效率，应该将标记接口（即没有方法的接口）放在限定列表的末尾。
    Java泛型的突出特性之一是在虚拟机中擦除泛型类型。令人奇怪的是，擦除的类仍然保留原先泛型的一些微弱记忆。

8、添加泛型后，与遗留代码互操作最差的情况也就是程序抛出一个异常，这种情况并不会比没有泛型时情况更糟糕。
9、你可以重新构造实现者声明的泛型类和方法的所有有关内容。但是，你不会知道对于特定的对象或方法调用会如何解析类型参数。
