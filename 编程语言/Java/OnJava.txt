1、很微妙的一件事是，一门语言会悄然无息地引导你进入某种思维模式，同时远离其他思维模式。Java尤其如此。
2、我个人认为，把所有内容都封装为对象不仅是一种负担，而且还会将许多程序设计推向错误的方向。
3、我想表达的是，如果你了解了一门语言的不足之处和局限性，当你遇到某个语言特性不可用时，就不会被卡住，以致无法继续。同时，因为你已经知晓其局限性，所以就可以更好地进行程序设计。
4、编程是一门管理复杂性的艺术，而问题的复杂程度取决于机器的复杂程度。由于这种复杂性的存在，导致了大多数编程项目的失败。
5、我相信有些细节对于95%的程序员而言是无关紧要的。这些细节只会让人们感到困惑，并且增加他们对于语言复杂度的认知。
6、每一种语言都存在设计缺陷。我认为，理解语言和库的设计缺陷是必要的，因为它们会影响程序员的生产力。
7、持续犯错的代价由别人承担，而承认错误的代价由你自己来承担。
8、更为关键的是，新手程序员并没有经历过“想不通为什么会这样”的痛苦挣扎，尤其是发现了某个看起来不对劲儿的地方之后所产生的自我怀疑，在这种情况下人们会很自然的认为“要么是自己做错了，要么就是自己还没有搞明白”。
9、所有编程语言都是一种抽象。
10、Alan Kay总结了SmallTalk语言的5个基本特征，这些特征代表了纯粹的面向对象编程的方式：
    万物皆对象；
    一段程序实际上就是多个对象通过发送消息来通知彼此要干什么；
    从内存角度而言，每一个对象都是由其他更为基础的对象组成的；
    每一个对象都有类型；
    同一类型的对象可以接收相同的消息；
11、对象具有状态、行为及标识。
12、动态创建对象的方案基于一个普通接受的逻辑假设，即对象往往是复杂的。所以在创建对象时，查找和释放内存空间所带来的额外开销不会造成严重的影响。此外，更大的灵活性才是解决常规编程问题的关键。
13、当你创建一个用于放置对象的数组时，实际上数组里包含的是引用，而这些引用会被自动初始化为一个特殊的值：null 。
14、方法名和参数列表共同构成了方法的“签名”（不包括返回类型），方法签名即该方法的唯一标识符。
15、正如很多相似情况下的典型做法，遵守中庸之道是最富有成效的。真正的问题并不在于goto本身，而在于滥用goto。在极少数场景下，goto实际上是组织控制流最好的方式。
16、遵循一致且直观的编程风格可以节省时间和金钱。
17、可以使用this调用另一个构造器，但不能同时调用两个。此外，构造器调用必须出现在方法的最开始部分，否则编译器会报错。
    可以使用super调用父类构造器，但它和this具有相同的限制（必须在第一行），所以在调用构造器时super和this也不能同时出现。
18、在你回收某个对象之前，如果要执行一些操作，那你必须自己去执行。Java没有析构函数或类似的概念，因此你必须创建一个普通方法来执行这个清理。
19、垃圾收集仅与内存有关。也就是说，垃圾收集器存在的唯一原因就是回收程序里不再使用的内存。所以任何与垃圾收集相关的活动，特别是finalize()方法，都必须与内存及其释放相关。
20、看起来之所以要有finalize()方法，是因为你可能没有使用Java中的通用方式来分配内存，而是采用了类似C语言的机制。这主要通过本地方法来实现，它可以在Java代码里调用非Java代码。Java里的本地方法目前只支持C和C++，但这些语言可以调用其他语言的代码，所以实际上Java可以调用任何代码。在非Java代码里，可能会调用C的malloc()系列函数来分配存储空间，此时除非明确调用了free()方法，否则该存储空间不会被释放，从而导致内存泄漏。free()是一个C和C++函数，所以需要在finalize()里通过本地方法来调用。
21、包访问权限只在当前包中可以访问。
    Java实质上不存在子包（子包只是形式上的父子关系，实质上是完全无关的两个包），所以不能在子包中访问包访问权限修饰的对象。
    protected修饰的对象也具有包访问权限，所以protected提供了比包访问权限更宽泛的访问控制。
    使用反射可以越过包访问权限的访问控制。
22、尽管不常见，但编译单元里可以没有public类。这时你可以随意命名文件（不过随意命名会给阅读和维护代码的人带来困扰）。
23、如果想要执行清理，请创建自己的清理方法（例如实现AutoCloseable接口）。在清理方法中，要注意清理方法的调用顺序，清理顺序一般与创建顺序相反，先清理子类对象，再清理父类对象，以防止子类对象的清理依赖于父类对象的存活。
24、从子类型转换为基类型会在继承图里向上移动，因此通常称为向上转型。向上转型总是安全的，因为你是从更具体的类型转为更通用的类型。也就是说，子类是基类的超集。它可能包含比基类更多的方法，但肯定至少会包含基类中的所有方法。在向上转型期间，类接口只能丢失方法，不能获得方法。这就是为什么编译器允许向上转型，而无须任何显式的转型或其他特殊符号。
25、不要陷入过早优化的诱惑之中。
26、抽象类可以不包含抽象方法，但包含抽象方法的类必须被定义为抽象类。
    不允许使用private修饰抽象方法，因为在子类中无法提供具体实现。
27、在JDK9中，接口里的default和static方法都可以是private的。
28、在接口继承时，可以使用extends继承多个接口。
29、在接口继承和接口实现时，不能同时存在方法签名相同但返回类型不同的接口方法，否则会造成冲突。
30、当实现一个接口时，并不需要实现嵌套在其中的接口。
31、JDK17引入了密封类和密封接口，可以限制能派生出哪些类。
    一个sealed类必须至少有一个子类。
    JDK16的record也可以用作接口的密封实现。因为record是隐式的final，所以它们不需要在前面加final关键字。
32、任何抽象都应该由真正的需求来驱动。接口应该是在必要时用来重构的东西，而不是在任何地方都多加一个间接层级，进而带来额外的复杂性。这种额外的复杂性影响很大，如果你让某人在克服这种复杂性上花费时间，而他最终却发现你添加接口只不过是为了“以防万一”，而非出于什么令人信服的其他理由——那好吧，如果我看到这样的设计，就会开始质疑这个人做过的其他所有设计。
33、一个比较恰当的指导方针是“优先使用类而不是接口”。从类开始设计，如果很明显接口是必要的，那么就重构。接口是一个很好的工具，但它很容易被滥用。
34、当创建一个内部类时，这个内部类的对象中会隐含一个链接，指向用于创建该对象的外围对象。通过该链接，无须任何特殊条件，内部类对象就可以访问外围对象的成员。内部类可以访问外围对象的所有方法和字段（包括private修饰的字段和方法），就好像拥有它们一样。
    可以使用外部类名称加上.this的语法引用创建内部类的外部类对象。
    可以使用外部类对象加上.new的语法创建内部类对象。
    除非已经有了一个外部类对象，否则创建内部类对象是不可能的。这是因为内部类的对象会暗中连接到用于创建它的外部类对象。
35、private内部类为类的设计者提供了一种方式，可以完全阻止任何与类型相关的编码依赖，并且可以完全隐藏实现细节。
36、内部类可以在一个方法内或者任何一个作用域内创建（局部内部类），但在定义它的作用域之外是不可用的。
37、如果你正在定义一个匿名类，而且一定要用到一个在该匿名类之外定义的对象，编译器要求参数引用用final修饰，或者是“实际上的最终变量”（也就是说，在初始化之后它永远不会改变，所以它可以被视为final的）。
38、因为匿名类没有名字，所以不可能有命名的构造器。借助实例初始化，我们可以在效果上为匿名内部类创建一个构造器。但我们无法重载实例初始化部分，所以只能有一个这样的构造器。
39、与普通的继承相比，匿名内部类有些局限性，因为它们要么是扩展一个类，要么是实现一个接口，但是两者不可兼得。而且就算要实现接口，也只能实现一个。
40、普通内部类对象中隐式地保留了一个对外部类对象的引用，嵌套类（static修饰的内部类）对象没有指向外部类对象的引用。
    无法从嵌套类对象内部访问非static的外部类对象。
    普通内部类不能包含static元素，嵌套类可以包含static元素。
41、嵌套类可以是接口的一部分。放到接口中的任何类都会自动成为public和static的。因为类是static的，所以被嵌套的类只是放在了这个接口的命名空间内。甚至可以在内部类内实现包围它的这个接口。
42、每个内部类都可以独立地继承自一个实现。因此，外部类是否已经继承了某个实现，对内部类并没有限制。所以从某种角度上讲，内部类完善了多重继承问题的解决方案。
43、内部类可以获得以下额外的能力：
    内部类可以有多个实例，每个实例都有自己的状态信息，独立于外围类对象的信息。
    一个外围类中可以有多个内部类，它们可以以不同方式实现同一个接口，或者继承同一个类。
    内部类对象的创建时机不与外围类对象的创建捆绑到一起。
    内部类不存在可能引起混淆的“is-a”关系，它是独立的实体。
44、闭包（closure）是一个可调用的对象，它保留了来自它被创建时所在的作用域的信息。从这个定义中，可以看到内部类是面向对象的闭包，因为它不仅包含外围类对象（“它被创建时所在的作用域”）的每一条信息，而且它自动持有着对整个外围类对象的引用。它有权操作外部对象中的所有成员，甚至是private成员。
45、人们认为Java应该包含某种指针机制，一个最有说服力的论据就是支持回调（callback）。通过回调，我们可以给其他某个对象提供一段信息，以支持它在之后的某个时间点调用回原始的对象中。
46、TreeMap会按照键的升序来排序，LinkedHashMap则按照插入顺序来保存键，同时保留了HashMap的查找速度。
47、集合类中的很多方法都依赖于持有对象的equals()方法。
48、ListIterator是Iterator的一种更为强大的子类型，只有List类才会生成。尽管Iterator只能向前移动，但是ListIterator可以双向移动。它还可以生成相对于迭代器在列表中指向的当前位置的下一个和上一个元素的索引，并且可以使用set()方法替换它所访问过的最后一个元素。
49、JDK16最终增加了record关键字。record定义的是希望成为数据传输对象的类（也叫数据载体）。
    编译器会自动为record类型生成equals()、hashCode()和toString()方法。要让一个类的对象可以用作Map（或Set）中的键，我们必须为这个类定义equals()和hashCode()。
    不能向record中添加字段，只能将其定义在头部。不过可以加入静态的方法、字段和初始化器。
    record不能继承其他类，但可以实现接口。
    record可以嵌套在类中，也可以定义在方法内。嵌套和局部的record隐含都是静态的。
    尽管规范的构造器会被根据record的参数自动创建出来，但是我们可以使用一个紧凑构造器来添加构造器行为，它看上去像一个构造器，但是没有参数列表。
    紧凑构造器通常用于验证参数，也可以修改字段的初始化值。
    如果有必要，我们可以使用普通构造器语法替换掉规范构造器。只有极少数情况才会用到record的普通构造器，如果一定要写一个构造器，优先使用紧凑构造器，它会为我们处理字段的初始化。
    要复制一个record，必须显式地将所有字段都传给其构造器。
50、队列在“并发编程”中特别重要，因为它们可以安全地将对象从一个任务转移到另一个任务。
51、队列和栈的行为都是通过LinkedList提供的。
52、生成一个Iterator，是将序列与处理序列的方法连接起来的耦合性最低的方式，与实现Collection相比，这样做对序列类的约束要少得多。
53、for-in使用Iterable接口遍历序列，任何实现了Iterable接口的类都可以用于for-in语句中。
54、Arrays.asList()产生的List对象，会使用原来的底层数组作为其物理实现，对List的修改会体现在数组中。
55、面向对象编程抽象数据，而函数式编程抽象行为。
56、lambda表达式产生的是函数，而不是类。在Java虚拟机上，一切都是类。这种转换是由编译器在幕后完成的。
57、在Java中也可以编写递归的lambda表达式，但是有一点要注意：这个lambda表达式必须被赋值给一个静态变量或一个实例变量，否则会出现编译错误。
58、在未绑定引用的情况下，函数式方法的签名与方法引用的签名不再完全匹配。这样做有一个很好的理由，那就是我们需要一个对象，让方法在其上调用。如果方法有很多参数，只要遵循第一个参数取的是this这种模式即可。
59、当使用函数式接口时，名字并不重要，重要的只有参数类型和返回类型。Java会将我们起的名字映射到接口的函数式方法上。
60、高阶函数只是一个能接受函数作为参数或能把函数当返回值的函数。
61、使用继承，可以轻松地为专门的接口创建一个别名。
62、这个规则并不是说“任何在lambda表达式之外定义的变量都必须是最终变量或实际上的最终变量”那么简单。我们必须从被捕获的变量是“实际上的最终变量”这个角度来考虑。如果它是某个对象中的一个字段，那么它会有独立的生命周期，并不需要任何特殊的捕获，以便在之后这个lambda表达式被调用时，变量仍然存在。
63、柯里化的意思是，将一个接受多个参数的函数转变为一系列只接受一个参数的函数。柯里化的目的是能够通过提供一个参数来创建一个新函数，所以我们现在有了一个“参数化函数”和剩下的“自由参数”。
64、如果并行是项目的核心部分，可以考虑至少在项目的一部分中使用Scala或Kotlin这样的语言。
65、lambda在Java中并非一等公民。
66、流是一个与任何特定的存储机制都没有关系的元素序列。
67、声明式编程是一种编程风格，我们说明想要完成什么，而不是指明怎么做，这就是我们在函数式编程中看到的。相比而言命令式编程理解起来要更困难。
68、显示编写的迭代机制，称为外部迭代，流采用隐式的内部迭代机制。内部迭代产生的代码不仅可读性更好，而且更容易利用多处理器：通过放宽对具体迭代方式的控制，我们可以将其交给某种并行化机制。
69、流的另一个重要方面是惰性求值，这意味着它们只在绝对必要时才会被求值。我们可以把流想象成一个“延迟列表”。因为延迟求值，所以流使我们可以表示非常大的（甚至是无限大的）序列，而不用考虑内存问题。
70、流的操作可分为三种类型：创建流、修改流元素（中间操作）和消费流元素（终结操作）。
71、流改变了Java编程的本质，而且带来了极大的提升。
72、下面是使用异常的一些指导原则：
    尽可能使用try-with-resources；
    要在恰当的层次处理问题（除非知道怎么处理，否则不要捕捉异常）；
    可以使用异常来修复问题，并重新调用引发异常的方法；
    可以选择做好补救措施然后继续，不再重新尝试引发异常的方法；
    可以借助异常处理的过程计算出某个结果，以代替该方法应该生成的值；
    可以在当前上下文中把能做的事情都做了，然后将相同的异常重新抛出，使其进入更上层的上下文中；
    可以在当前上下文中把能做的事情都做了，然后重新抛出一个不同的异常，使其进入更上层的上下文中；
    使用异常来终止程序；
    使用异常来简化问题；（如果你的异常模式使问题更复杂了，用起来会非常麻烦）
    使用异常让我们的库和程序更安全；
73、异常情形是指阻止当前方法或作用域继续执行的问题。区分异常情形和普通问题非常重要，所谓的普通问题是指，在当前上下文中我们有足够的信息，能够以某种方式解决这个难题。而异常情形是指，因为在当前上下文中我们没有必要的信息来处理这个问题，所以无法继续处理。我们所能做的就是跳出当前上下文，并将问题委托给更上层的上下文。这就是抛出异常时所发生的事情。
74、有时我们会捕捉一个异常并抛出另一个，但仍然保留原始异常的信息，这称为异常链。
75、Java类Throwable描述了任何可以被当作异常抛出的事物。有两个常用的继承自Throwable的类型：Error和Exception。Error代表的是编译时错误和系统错误，除了个别极特殊的情况，我们不用关心其捕获。Exception通常是我们最关心的异常类型，RuntimeException是个特例。
76、编译器强制要求对所有的检查型异常都必须进行显式的处理，非检查型异常则没有强制要求。
77、在继承和重写的过程中，只能抛出该方法的基类版本中说明的异常。“异常说明”可以缩小，但是不能扩大。通过强制子类的方法遵守基类方法的异常说明，对象的可替换性得以保持。
    对异常的这些约束并不适用于构造器。子类构造器必须在其异常说明中声明基类构造器提到的异常，另外还可以添加任何想要抛出的异常。
78、尽管编译器会在继承过程中强制保证异常说明的执行，但是异常说明并不是方法签名的一部分——方法签名只包括方法名和参数。因此，不能依赖异常说明的不同来重载方法。
79、对于可能在构造过程中抛出异常而且需要清理的类，最安全的用法是使用嵌套的try块。
80、即使构造器不会抛出任何异常，也应该使用这种通用的清理惯用法。其基本规则是，在创建了一个需要清理的对象之后，直接跟一个try-finally块。
81、异常处理如此复杂，说明应该创建不可能失败的构造器，尽管这并非总是可能的。
82、在try-with-resources语句中，退出try块时会以与创建顺序相反的顺序关闭它们。
83、如果构造器失败了（抛出异常），我们不能假定可以在这个对象上安全地执行任何操作，包括关闭它在内。
84、当一个异常被抛出时，异常处理系统会按照处理程序的编写顺序来寻找“最近的”那个。当找到一个匹配的处理程序时，它会认为该异常得到了处理，从而不再进行进一步的搜索。
85、异常处理的一个重要准则是：“除非你知道该如何处理，否则不要捕捉异常”。事实上，异常处理的一个重要目标是将处理错误的代码从错误发生的地点抽离出来。这样我们就可以把自己的注意力集中到代码的某个部分上，而有关如何处理问题的代码则放到一个单独的地方。因此，我们的主线代码不会被错误处理的逻辑所干扰，而且更容易理解和维护。
    异常可以降低错误处理代码的复杂性。理想情况下，我们只在一个地方处理这个问题，也就是在所谓的异常处理程序中。这可以节省代码，并将正常执行时描述我们目标的代码与出现问题时执行的代码分离开来。
    关于异常有个基本的假设：将所有的错误处理代码收集起来放在代码块的末尾，而不是在错误发生的时候直接处理，能够带来某种好处。
86、检查型异常实际上是Java的发明。然而，这只是一次尝试，之后的编程语言并没有采用这样的做法。
87、考查小型程序会得到这样的结论：要求异常说明，既可以提高开发人员的效率，又可以增强代码质量。但大型软件项目的经验给出了不同的结论：开发效率下降，代码质量几乎没有提高。
88、Java走出的重要一步是统一了错误报告的模型，因此所有的错误都是使用异常来报告的。
89、减少编译时对程序员的约束，对于提升开发效率也有很大的帮助。
90、好的编程语言能帮助程序员写出好的程序。没有任何编程语言能够阻止程序员写出糟糕的程序。
91、通过将一个检查型异常传递给RuntimeException构造器，我们可以将其包在一个RuntimeException中。这似乎是“关闭”检查型异常的理想方式：我们没有“吞掉”它，也没有将其放在方法的异常说明中，但是由于异常链的存在，我们不会丢失来自原始异常的任何信息。
92、异常处理的优点之一就是，它使得我们可以在一个地方集中精力处理所要解决的问题，然后在另一个地方处理来自这些代码的错误。尽管异常通常被解释为允许我们在运行时报告错误以及从错误中恢复的工具，但我怀疑“恢复”能在多少情况下实现，甚至有没有可能实现。我认为这样的情况不到10%，即便如此，其中还有相当大的比例只是将栈展开到一个已知的稳定状态，而不是真正执行了任何恢复行为。无论这是否正确，我相信“报告”功能是异常的基本价值所在。Java坚持所有错误都要以异常的形式报告，与C++等语言相比，这是一个巨大的优势。这是因为C++允许我们以几种不同的方式报告错误，或者根本就不报告。
93、我对GO编程语言很着迷，因为Rob Pike等人明确提出了关于语言设计的很多基础且深刻的问题。基本上，他们会审视我们已经开始接受的关于语言的一起，然后问一下“为什么”。学习这门语言真的会引发你的思考和好奇心。
    他们似乎并不担心所做的修改会破坏旧代码——他们还创建了一个重写工具，所以如果他们做了这样的修改，这个工具可以帮着重写代码。这使他们可以把语言变成一个持续的实验，以发现什么是真正必要的，而不是做大而全的预先设计。
    他们做出的最有意思的决定之一是完全不考虑异常。你没有看错，他们不是仅仅舍弃了检查型异常，而是舍弃了所有的异常。
94、你永远无法保证自己的代码是正确的。（你无法证明自己的代码没有问题）
95、C风格的编程语言，尤其是C++，传统上更重视性能而不是编程安全。用Java开发程序比用C++快得多（大多数情况下前者速度是后者的两倍）
96、测试覆盖率（也称代码覆盖率）是衡量代码库的测试百分比。百分比越高，测试覆盖率越大。通常测试覆盖率应该保持在一个合理的区间，以保证测试的有效性。太高或太低的测试覆盖率都是有问题的。
97、测试驱动开发(TDD)的前提是，如果在设计和编写代码时考虑到测试，你不仅会创建可测试的代码，而且代码的设计会变得更好。总的来说，这似乎是正确的。如果在开发时想着“我将如何测试这段代码”，这会使代码变得不一样，而通常来说，“可测试”的代码“可用性”也更高。
98、纯测试优先编程的主要问题是，它假设你预先了解正在解决的问题的一切。根据我自己的经验，我通常从试验开始，对这个问题已经研究了一段时间后，我才能很好地理解它并编写测试。
99、通常，简单直接的编程方法就足够了。如果进行了不必要的优化，会使你的代码变得过于复杂和难以理解。
100、基准测试意味着对代码或算法进行计时，以查看哪些运行的更快。
    Java微基准测试系统是Java微基准测试工具(JMH)。
101、有时你需要检测自己程序的运行时间都花在哪里，查看哪部分的性能可以提高。分析器可以找到耗时的部分，这样你就可以通过最简单、最明显的方法来加快速度。
    请注意分析和基准测试之间的区别。分析着眼于处理实际数据的完整程序，而基准测试着眼于程序的一个独立片段，通常是为了优化算法。
    JDK附带了一个名为VisualVM的可视化分析器。
102、关于优化的一些建议：
    避免为了性能而牺牲代码可读性；
    不要孤立地看待性能。权衡付出的努力与获得的好处；
    程序的大小很重要。性能优化通常只对长时间运行的大型项目有价值。小型项目通常不需要关心性能；
    让程序先正常工作比努力提高其性能更重要。一旦有了一个能运行的程序，你就可以在必要时使用分析器来提高它的效率。仅当性能是关键因素时，才应该在初始设计/开发阶段就考虑性能；
    不要猜测性能瓶颈在哪里，运行分析器来获取该数据；
    JVM会优化static final变量来提高程序速度。因此，程序常量应该声明为static final的；
103、单元测试能发现一些重要类别的错误。Checkstyle和Findbugs能执行自动代码审查，从而发现其他问题。最终，我们还需要将人工代码审查添加到这个组合中。
104、结对编程有很多好处，但最引人注目的两个好处是共享知识和防止信息阻塞。传递信息的最佳方式之一是共同解决问题，我在许多研讨会中使用结对编程，取得了很好的效果。
105、实际上，没有任何事情按计划或安排正常进行。
106、代码验证不是单一的过程或技术。任何一种方法都只能找到特定类别的错误。作为一名程序员，随着你的持续成长，你了解到的每一种额外的技术都会增加代码的可靠性和稳定性。
107、Path接口：
    Path对象代表的是一个文件或目录的路径。基本上等同于以前的File对象；
    Paths工具类的静态方法可以用来构建Path对象；
    Files工具类的静态方法可以用来分析Path对象；
    Path实现了Iterable接口，所以可以在for-in结构中进行遍历；
    Path遍历时，没有包含根目录；
    startsWith和endsWith方法比较的是路径组件，不是字符串。所以 endsWith(".{txt}") 这种以扩展名判断的方法会返回false（不要使用这种判断方法）；
    PathMatcher有两种模式可以实现对文件的查找过滤：glob 和 regex ；
108、WatchService使我们能够设置一个进程，对某个目录中的变化做出反应。监听只对当前目录有效，不包括子目录。
109、使用JDK自带的javap工具可以反编译（通过.class文件）查看字节码：
        javap -c ClassName
110、Java5提供了类似C语言中的printf()语句风格的格式化输出，printf内部调用了format方法，所以它们是等价的。
111、Java中所有的格式化功能都由java.util包里的Formatter类处理。
112、Java5还借鉴了C语言中用来创建字符串的sprintf()，提供了String.format()方法。它是一个静态方法，参数与Formatter类的format()方法完全相同，但返回一个String。
113、JDK15最终添加了文本块，这是从Python语言借鉴而来的一个特性。使用三引号来表示包含换行符在内的多行文本。
    注意：开头的"""后面的换行符会被自动去掉，块中的公用缩进也会被去掉。如果想要保留缩进，那就移动最后的"""来产生所需的缩进。
114、Java一开始设计的时候并没有考虑到正则表达式，所以在Java中使用正则表达式的特殊字符时，需要多加一层反斜杠（\）。例如，我们需要使用四个反斜杠才能匹配单个反斜杠。
115、Java的正则表达式工具类位于java.util.regex包，其中最常用的是Pattern类和Matcher类。
    你的目标应该是创建能完成工作的最简单的正则表达式；
    分组是用括号括起来的正则表达式，后续代码里可以用分组号来调用他们。分组0表示整个表达式，分组1是第一个带括号的分组，以此类推；
    在匹配成功之后，start()返回本次匹配结果的起始索引，而把本次匹配结果最后一个字符的索引加上1，就是end()的返回值。如果匹配不成功（或在尝试匹配操作之前），这时调用start()或end()会产生一个IllegalStateException；
    Pattern类的compile()方法还有一个重载版本，它可以接受一个标记参数，来影响匹配行为；
116、量词描述了一个正则表达式模式处理输入文本的方式：
    量词默认是贪婪的，除非另有设置。贪婪型表达式会为模式找到尽可能多的匹配项，这可能会导致问题。我们经常会犯的一个错误就是，认为自己的模式只会匹配第一个可能的字符组，但实际上它是贪婪的，会一直持续执行，直到找到最大的匹配字符串；
    勉强型（用？指定）会匹配满足模式所需的最少字符数。也称为惰性匹配或最小匹配；
    占有型匹配仅适用于Java（不适用于其他语言），它不保留中间状态，可以防止回溯；
117、Scanner会假设IOException表示输入结束，因此Scanner会把IOException隐藏起来。不过最近发生的异常可以通过它的ioException()方法获得，因此你可以在必要时检查它。
118、反射可以在程序运行时发现并使用对象的类型信息。
119、Java程序在运行前并不会被完全加载，而是在必要时加载对应的部分。类在首次使用时才会被动态加载到JVM中。程序中的每个类都有一个Class对象。
120、类加载器子系统实际上可以包含一条类加载器链，但里面只会有一个启动类加载器，它是JVM实现的一部分。启动类加载器通常从本地磁盘加载所谓的可信类，包括Java API类。
121、使用一个类之前，类加载器会执行以下3个步骤：加载、链接、初始化。初始化会“尽可能懒惰”。
122、如果使用instanceof进行类型检查，则包括了子类；如果使用==比较Class对象，则不包括子类。
123、Class类和java.lang.reflect库一起支持了反射，这个库里包含Field、Method以及Constructor类（它们都实现了Member接口）。
124、自动生成的无参构造器会自动获得与类相同的访问权限。
125、在实际应用中，到处使用Optional是没有意义的——有时判断一下是否为null没什么不好，有时你可以合理地假设自己不会遇到null，有时甚至通过NullPointerException来检测异常也是可以接受的。Optional看起来在“更接近数据”的地方最有用，此时对象代表问题空间中的实体。
126、极限编程的一项宗旨就是“尝试最简单且可行的事情”。（You Aren't Going to Need It，你并不需要它）
127、没有任何方法可以阻止反射进入并调用非公共访问权限的方法。不过，final字段实际上是安全的，不会发生变化。运行时系统在接受任何更改尝试时并不会报错，但实际上什么也不会发生。
    程序员经常对语言提供的访问控制过于自信，以至于相信在安全性方面，Java比其他提供了不太严格的访问控制的语言更优越。正如你所看到的，事实并非如此。
128、如果你之前从未见过任何形式的参数化类型机制，那么Java泛型可能看起来就像一种提升语言便利性的附加能力。在创建某个参数化类型的实例时，类型转换会自动发生，并且会在编译期确保类型的正确性。
129、清楚哪些事情不能做，能让你更好地利用那些你所能做的事情（部分原因是可以让你无须浪费时间走死胡同了）。
130、泛型最重要的初衷之一，是用于创建集合类。最没有争议的泛型类型机制的适用场景之一，就是用于诸如List、Set、Map等集合类。
131、元组将一组对象包装进一个对象，该对象的接收方可以读取其中的元素，但不能往里放入新元素。（这个概念也称为数据传输对象或信使）
132、泛型代码内部并不存在有关泛型参数类型的可用信息。Java泛型是通过类型擦除实现的。这意味着在使用泛型时，任何具体的类型信息都将被擦除。
133、要想从心底里消除关于类型擦除的任何疑虑，你必须清楚地明白它并不是一项语言特性。它是在Java泛型实现中必要的一种折中，因为泛型并不是这门语言与生俱来的一部分。
134、泛型类型只在静态类型检查时期存在，在这之后，程序中所有的泛型类型都会被擦除，并替换为它们的非泛型上界。
135、类型擦除的核心初衷是，希望让泛化的调用方程序可以依赖于非泛化的库正常使用，反之亦然。这通常称为迁移兼容性。
136、库可以说是一门编程语言最有影响力的组成部分。
137、由于类型擦除移除了方法体中的类型信息，运行时的关键便指向了边界——对象进入和离开某个方法的临界点。编译器会在编译时在临界点执行类型检查，并插入类型转换的代码。
138、因为警告往往会成为一种噪声，所以一旦验证了某条警告是符合预期的（即确认不会有影响）之后，最好用@SuppressWarnings注解来关闭该警告。
    对于警告，只要可以忽略，就一定会忽略。出于这个原因，除非是代码编写者必须要处理的问题，否则最好不要让编译器发出任何消息（警告）。
139、我们无法声明 T[] array = new T[sz] ，因此我们可以创建一个对象数组，并对它进行转型。由于类型擦除的缘故，数组的运行时类型只能是 Object[] 。如果我们立刻将其转型为 T[] ，那么在编译时，数组的实际类型便会丢失，编译器就可能会错过对某些潜在错误的检查。因此，更好的办法是在集合内使用 Object[] ，并在使用某个数组元素的时候增加转型为 T 的操作。
    没有任何办法可以推翻底层的数组类型，该类型只能是 Object[] 。在内部将array当作 Object[] 而不是 T[] 来进行处理，这样做的好处是，可以减少由于你忘记了数组的运行时类型，而意外产生bug的可能性。
    在Java文献中往往会推荐使用类型标记的技巧。
140、即使Java库的源代码中出现了某些惯用做法，这也不一定是正确的做法。你在阅读库代码的时候，不能把这些当成可以在自己的代码中遵循的范例。（Java库中到处都有将Object数组转型为参数化类型的操作）。
141、List实际上是指“持有任意Object类型的原生List”，而List<?>是指“持有某种具体类型的非原生List”，但我们并不知道是什么类型。
142、编译器无法知道类型转换是否是安全的。有时使用泛型并不意味着不需要转型，而这会导致编译器产生不正确的警告。
143、这便是CRG的精髓了：基类用子类替换了其参数。这意味着泛型基类变成了一种为其子类实现通用功能的模板，但是所实现的功能会将派生类型用于所有的参数和返回值。也就是说，最终类中使用的是具体的类型，而不是基类。
144、自限定类型的价值在于它可以生成协变参数类型——方法参数的类型会随着子类而变化。虽然自限定类型也可以生成和子类类型相同的返回类型，但这并不那么重要，因为Java5中引入了协变返回类型。不过，在非泛型的代码中，参数的类型无法随子类型变化。
145、混型有多种含义，但其最基本的概念是混合多个类的能力，以生成一个可以代表混型中所有类型的类。混型有一些面向切面编程的味道，而切面常常被推荐用于解决混型问题。
146、泛型类无法直接继承自泛型参数。
147、装饰器是通过组合和规范的结构实现的，而混型是基于继承的。
148、某些编程语言提供了一种称为潜在类型机制或结构化类型机制的解决方案。这种方案还有个更为异想天开的名称：鸭子类型机制，展开来说就是“如果某个事物走路像鸭子，说话也像鸭子，那么你就可以把它也当成鸭子”。
149、大部分时候你应该首要考虑使用Java8的函数式方式，只在某些仅有反射可以处理的特殊需求场景下，才考虑使用反射。
150、因此即使“在cat list中放入了dog”的论点经常被拿来评判泛型，它还是应该被质疑的。
151、泛型正如它的名字所示，是一种编写更泛型（generic）的代码的方法，使得代码可以更少受到适用类型的限制，因此一段代码可以应用于更多的类型。
152、要编写操作泛型参数的泛型代码，不论是类的创建者还是使用者，都需要付出额外的努力，两者都需要理解这种代码的概念和具体实现。这些额外的努力降低了该特性的易用性，并因此减少了它在某些本可以带来更多价值的场合下的适用性。
153、数组是一等对象。
154、类型擦除移除了参数的类型信息，所以数组必须清楚地知道自身所保存的具体类型（通常无法直接创建泛型类型的数组），以保证类型安全。
155、相较于参数化类，参数化方法通常更方便。你无须每应用到一种类型都要实例化一个带参数的类，并且该类还可以是静态的。你无法每次都选择使用参数化方法而不是参数化类，但前者通常都会更好一些。
156、应该优先选择集合而不是数组，只有当你能证明性能成了问题，并且如果改用数组实现可以显著改善问题时，才应该重构为数组。
157、在不少讨论中能听到这样的声音：“C++是一门设计拙劣的语言”。我则认为理解C++和Java做出的各种决策有助于站在更高的位置看待问题。
    尽管如此，我现在也很少使用C++了。
158、自C++标准委员会诞生之日起，我担任了8年委员，因此见证了这些设计决策的诞生。这些决策都经过极其慎重的考虑，远远超过了Java所做的许多决策。
159、要理解C++语言为什么既复杂难用又有优秀的设计，就必须时刻牢记C++中一切设计的首要目标：兼容C语言。
160、由于某些原因，Java7和Java8中的很多决策要远远好于之前，但是向后兼容性的约束始终是Java向伟大迈进的阻碍。Java语言的初心已不再——初心易得，始终难守。
161、现在，任何人都可以创建一门新的语言，并在短时间内使其像Java一样高效地运行。但在以前，对于一门新的语言来说，大部分开发时间往往花在实现正确、高效的编译器上。