# Java加密与解密的艺术（第2版）

## 第 1 章  企业应用安全

1. 加密是提高数据安全性最简便的方法。
2. SSL/TLS协议成为网络上最常用的安全保密通信协议，众多电子邮件、网银、电子商务、网上传真都通过SSL/TLS协议确保数据传输安全。
3. HTTPS协议是Web上最为常用的安全访问协议，广泛应用于互联网上的敏感数据交互，例如B2C、网上银行、企业应用之间的数据传递等。
4. 密码学在加密算法上大体可分为单向加密算法、对称加密算法、非对称加密算法三大类。  
    MD5、SHA算法是单向加密算法的代表，单向加密算法是数据完整性验证的常用算法。  
    DES算法是对称加密算法的典型代表，对称加密算法是数据存储加密的常用算法。  
    RSA算法是非对称加密算法的典型代表，非对称加密算法是数据传输加密的常用算法。  
    对称加密算法也可以用做数据传输加密，但非对称加密算法在密钥管理方面更有优势。  
    相对对称加密算法而言，非对称加密算法在安全级别上等级更高，但非对称加密算法在时间效率上远不如对称加密算法。
5. 数字证书鉴于自身高度的安全性通常以文件形式存储，可通过网络、物理存储载体发送给用户使用。  
    通常在电子商务中，使用数字证书是最好的选择，也是确保安全交易的唯一选择。
6. OSI参考模型在原有网络通信七层结构的基础上构建了OSI安全体系结构，它由五类安全服务和八类安全机制构成。  
    五类安全服务以安全技术目标为主旨，包括认证（鉴别）服务、访问控制服务、数据保密性服务、数据完整性服务和抗否认性服务；  
    八类安全机制针对五类安全服务做了详尽的补充，包括加密机制、数字签名机制、访问控制机制、数据完整性机制、认证机制、业务流填充机制、路由控制机制和公证机制。

## 第 2 章  企业应用安全的银弹—密码学

1. 密码学包含密码编码学（Cryptography）和密码分析学（Cryptanalyst）两个分支。  
    密码编码学针对于信息如何隐藏；密码分析学针对于信息如何破译。  
    编码学与分析学相互影响，共同促进密码学的发展。
2. 密码系统（Cryptography）：指用于加密和解密的系统。  
    加密时，密码系统输入明文和加密密钥，进行加密变换后，输出密文；  
    解密时，密码系统输入密文和解密密钥，进行解密变换后，输出明文。
3. 柯克霍夫原则即数据的安全基于密钥而不是算法的保密。  
    换句话说，系统的安全性取决于密钥，对密钥保密，对算法公开。
4. 在手工加密阶段和机械加密阶段，流密码曾是当时的主流。  
    流密码实现较为简单，加密时将明文按字符（或字节）逐位进行加密，解密时将密文按字符（字节）逐位解密。明文加密后，生成的密文几乎和明文保持同样的长度。
5. 流密码分为同步流（序列）密码和自同步流（序列）密码。  
    同步流密码具有同步性、无错误传递性及主动攻击性三种特性。同步流密码适用于为音频和视频数据提供版权保护。  
    与同步流密码相比，自同步流密码的密码分析更加困难，安全性更高。因此，自同步流密码具有自同步性、错误传递有限性、主动攻击性及明文统计扩散性四种特性。  
    目前使用较多的流密码是自同步流密码。流密码的常用算法有RC4和SEAL等。
6. 现代密码学的研究主要关注分组密码和流密码及其应用。  
    在对称密码体制中，大部分加密算法属于分组密码。
7. 分组密码的设计原则包括安全性和实现性两个方面。  
    前者主要研究如何设计安全算法、分组长度和密钥长度，后者主要讨论如何提高算法的执行速度。
8. 分组密码对固定长度的一组明文进行加密，这一固定长度称为分组长度。  
    目前，分组密码多选择128位作为算法的分组长度。  
    分组长度是分组密码的一个参数，它与分组算法的安全性成正比，其取值范围取决于实际应用的环境。  
    为保证分组算法的安全性，分组长度越长越好，分组长度越长，密码分析越困难；为保证分组密码的实用性，分组长度越短越好，分组长度越短，越便于操作和运算。  
    分组密码算法从本质上来说是定义了一种从分组的明文到相应的密文的可逆变换。  
    分组密码多应用于网络加密，是对称密码体制中发展最为完善的密码体制。  
    分组密码是现代密码学的重要组成部分，具有代表性的分组加密算法有DES、AES等。
9. DES标准根据数据加密时每个加密区块间的关联方式来区分，可以分为4种工作模式：  
    电子密码本模式（Electronic Code Book，ECB）、密文链接模式（Cipher Book Chaining，CBC）、密文反馈模式（Cipher Feed Back，CFB）、输出反馈模式（Output Feed Back，OFB）。  
    AES标准除了推荐上述4种工作模式外，还推荐了一种新的工作模式—计数器模式（Counter，CTR）。
10. 非对称密码体制的主要优点是可以适应开放性的使用环境，密钥管理问题相对简单，可以方便、安全地实现数字签名和验证。  
    RSA是非对称密码体制的典范，它不仅可以完成一般的数据保密操作，同时它也支持数字签名与验证。  
    非对称密码算法的安全性完全依赖于基于计算复杂度上的难题，通常来自于数论。  
    例如，RSA源于整数因子分解问题；DSA—数字签名算法，源于离散对数问题；ECC—椭圆曲线加密算法，源于离散对数问题。
11. 散列函数广泛用于信息完整性的验证，是数据签名的核心技术。  
    散列函数的常用算法有MD（消息摘要算法）、SHA（安全散列算法）及Mac（消息认证码算法）。
12. 数字签名离不开非对称密码体制，签名算法受私钥控制，且由签名者保密；验证算法受公钥控制，且对外公开。  
    RSA和DSA是两种最流行的数字签名机制。  
    RSA算法既是最为常用的非对称加密算法，又是最为常用的签名算法。  
    DSA算法是典型的数字签名算法，虽然其本身属于非对称加密算法，但不具备数据加密与解密的功能。 ？  
    基于数字签名的不可伪造性，数字签名技术成为5种安全服务中数据完整性服务、认证性服务和抗否认性服务的核心技术。
13. 作者仍建议大家对消息先做签名，再做加密处理。加密与签名都应该只针对原始消息（明文）做处理。  
    加密是为了确保消息在传送过程中避免被破解，签名是为了确保消息的有效性。
14. 公钥基础设施（Public Key Infrastructure，PKI）是一个基于X.509的用于创建、分配和撤回证书的模型。  
    PKI能够为所有网络应用提供加密和数字签名等密码服务及所必需的密钥和证书管理体系。  
    PKI利用公钥密码技术构建基础设施，为网上电子商务、电子政务等应用提供安全服务。  
    PKI系统由认证中心（Certificate Authority，CA）、数字证书库（Certificate Repository, CR）、密钥备份及恢复系统、证书作废系统，以及应用程序接口（Application Programming Interface，API）五部分组成。其中，认证中心CA和数字证书库是PKI技术的核心。
15. 相比PKI，PGP根本不需要HTTPS，也不需要CA，仅需要一个可信赖的密钥托管服务器（基于LDAP的服务器）。  
    PGP依赖于非公钥体制，用公钥对数据加密，用私钥对加密后的数据解密，黑客却无法通过公钥破解密文。  
    而我们已知的PKI，是通过非公钥体制进行对称密钥交换，转而使用对称密钥完成加密操作。

## 第 3 章  Java加密利器

1. JCA和JCE是Java平台提供的用于安全和加密服务的两组API。它们并不执行任何算法，它们只是连接应用和实际算法实现程序的一组接口。
2. Provider类覆盖Properties类方法的目的在于确保程序有足够的权限执行相应的操作。这方面涉及安全管理器的概念（SecurityManager）。
3. Security类的任务是管理Java程序中所用到的提供者类。  
    这里有一个优先使用的问题，也就是说位置与优先级成正比，提供者位置越靠前，优先级越高。
4. MessageDigest类实现了消息摘要算法，是Java安全提供者体系结构中最为简单的一个引擎类。
5. Key接口是所有密钥接口的顶层接口，一切与加密解密有关的操作都离不开Key接口。  
    SecretKey（javax.crypto.SecretKey）接口是对称密钥顶层接口。  
    PublicKey、PrivateKey接口是非对称密钥顶层接口。
6. AlgorithmParameters类是一个引擎类，它提供密码参数的不透明表示。  
    AlgorithmParameters对象只能被初始化一次，无法重用。  
    当使用Java提供的加密组件时，很少会用到AlgorithmParameters和AlgorithmParameterGenerator两个类，当对算法参数要求极为严格的情况下才会考虑使用这种方式。
7. KeyPair类是对非对称密钥的扩展，它是密钥对的载体，我们把它称为密钥对。
8. KeyPairGenerator类提供了非对称密钥对的生成实现，如果要生成私钥，则可使用KeyGenerator（javax.crypto.KeyGenerator）类。  
    参数 int keysize 用来控制密钥长度，单位为位。
9. KeyFactory类也是用来生成密钥（公钥和私钥）的引擎类，我们将它称为密钥工厂，它用来生成公钥/私钥，或者说它的作用是通过密钥规范还原密钥。  
    与KeyFactory类相对应的类是SecretKeyFactory类，这个类用于生成秘密密钥。
10. SecureRandom类继承于Random类（java.util.Random），它起到强加密随机数生成器（Random Number Generator，RNG）的作用，我们称之为安全随机数生成器，它同样是一个引擎类。  
    SHA1PRNG算法是SecureRandom的默认算法。
11. Signature类用来生成和验证数字签名，它同样是一个引擎类。
12. SignedObject类是一个用来创建实际运行时对象的类，在检测不到这些对象的情况下，其完整性不会遭受损害。  
    更明确地说，SignedObject包含另外一个Serializable对象，即要签名的对象及其签名，我们可以称之为签名对象。  
    签名对象是对原始对象的“深层复制”（以序列化形式），一旦生成了副本，对原始对象的进一步操作就不再影响该副本。
13. Timestamp类用于封装有关签署时间戳的信息，且它是不可更改的。  
    它包括时间戳的日期和时间，以及有关生成和签署时间戳的Timestamping Authority（TSA）的信息。
14. CodeSigner类封装了代码签名者的信息，且它是不可变的，我们称之为代码签名。  
    它和数字时间戳（java.security.Timestamp）紧密相连。
15. KeyStore类被称为密钥库，用于管理密钥和证书的存储。  
    KeyStore 类是个引擎类，它提供一些相当完善的接口来访问和修改密钥仓库中的信息。
16. 安全消息摘要又称消息认证（鉴别）码（Message Authentication Code，Mac）。  
    Mac属于消息摘要的一种，但它不同于一般消息摘要（如MessageDigest提供的消息摘要实现），仅通过输入数据无法获得消息摘要，必须有一个由发送方和接收方共享的秘密密钥才能生成最终的消息摘要—安全消息摘要。
17. Cipher类为加密和解密提供密码功能。它构成了Java Cryptographic Extension（JCE）框架的核心。  
    除了完成数据的加密与解密，Cipher类还提供了对密钥的包装与解包。  
    CipherInputStream和CipherOutputStream同属Cipher类的扩展，统称为密钥流。
18. SealedObject类使程序员能够用加密算法创建对象并保护其机密性。
19. java.security.spec包和javax.crypto.spec包都提供了密钥规范和算法参数规范的类和接口。获得密钥规范后，我们将有机会还原密钥对象。
20. KeySpec接口不包含任何方法或常量。它仅用于将所有密钥规范分组，并为其提供类型安全。  
    所有密钥规范都必须实现此接口。  
    SecretKeySpec类是KeySpec接口的实现类，用于构建秘密密钥规范。
21. AlgorithmParameterSpec接口不包含任何方法或常量。它仅用于将所有参数规范分组，并为其提供类型安全。  
    所有参数规范都必须实现此接口。
22. EncodedKeySpec类用编码格式来表示公钥和私钥，我们称之为编码密钥规范。  
    X509EncodedKeySpec和PKCS8EncodedKeySpec两个类在加密解密环节中经常会用到。密钥很可能会以二进制方式存储于文件中，由程序来读取。这时候，就需要通过这两个类将文件中的字节数组读出转换为密钥对象。
23. java.security.cert包提供证书解析和管理、证书撤销列表（CRL）和证书路径的类和接口。
24. Certificate类是一个用于管理证书的抽象类。  
    证书有多种类型，如X.509证书、PGP证书和SDSI证书，并且它们都以不同的方式存储并存储不同的信息，但却都可以通过继承Certificate类来实现它们。
25. CertificateFactory类是一个引擎类，我们称之为证书工厂，可以通过它将证书导入程序中。
26. 证书可能会由于各种原因失效，如由于申请证书的请求有问题或者用户使用该证书做了非法操作，这时证书将立即被置为无效。  
    将证书置为无效的结果就是产生CRL（证书撤销列表）。  
    CA负责发布CRL，CRL中列出了该CA已经撤销的证书。  
    验证证书时，首先需要查询此列表，然后再考虑接受证书的合法性。  
    CRL类作为证书抽象列表的抽象类，可通过扩展该抽象类定义专门的CRL类型。
27. CertPath类是一个抽象类，定义了常用于所有CertPath的方法。其子类可处理不同类型的证书。  
    所有CertPath对象都包含类型、Certificate列表及其支持的一种或多种编码。  
    由于CertPath类是不可变的，所以构造CertPath后无法以任何外部可见的方式更改它。此规定适用于此类的所有公共字段和方法，以及由子类添加或重写的所有公共字段和方法。  
    CertPath类作为证书链，它的操作离不开CertPathBuilder类和CertPathValidator类。
28. javax.net.ssl包提供用于安全套接字包的类。
29. KeyManagerFactory类是一个引擎类，它用来管理密钥，称为密钥管理工厂。
30. TrustManagerFactory类是用于管理信任材料的管理器工厂。  
    除了通过KeyManagerFactory和TrustManagerFactory两个工厂类来设定密钥库和信任库外，还可以通过System.setProperty(String key, Object value)进行密钥库、信任库文件路径及密码的设定。

31. 重要类：

    ```text
        java.security.
            Provider
            Security
            MessageDigest
            DigestInputStream
            DigestOutputStream
            Key
            PublicKey
            PrivateKey
            KeyPair
            KeyPairGenerator
            KeyFactory
            SecureRandom
            Signature
            SignedObject
            Timestamp
            CodeSigner
            KeyStore

        java.security.spec.
            KeySpec
            AlgorithmParameterSpec

        java.security.cert.
            Certificate
            CertificateFactory
            CRL
            CertPath

        javax.crypto.
            SecretKey
            Mac
            KeyGenerator
            SecretKeyFactory
            Cipher
            SealedObject

        javax.crypto.spec.
            SecretKeySpec
    ```

## 第 4 章  他山之石，可以攻玉

1. Bouncy Castle是一款开源组件，提供了一系列算法支持实现，并可以跻身于JCE框架之下，以提供者的方式纳入其中。
2. Commons Codec是Apache旗下的一款开源软件，它并未对Java提供扩展加密算法，仅仅是对Java提供的API做了扩展，提供了更加易用的API。  
    Commons Codec主要用于编码格式的转换，如Base64、二进制、十六进制、字符集和Url编码的转换。
3. 需要注意的一点是，Bouncy Castle和Commons Codec对于Url Base64算法的理解上有所不同。  
    关于Url Base64算法，本身没有一个统一的标准，没有像RFC 2045这样的明文规定。
4. DigestUtils类是一个工具类，它提供了MD5和SHA系列消息摘要算法的实现。

## 第 5 章  电子邮件传输算法—Base64

1. 电子邮件只允许使用ASCII码，而对于非ASCII码（如中文）就显得无能为力了。  
    为了能在电子邮件中使用非ASCII码，就有了Base64算法。
2. 经过Base64编码后的数据会比原始数据略长，为原来的4/3倍。  
    经Base64编码后的字符串的字符数是以4为单位的整数倍。
3. Url Base64算法主要是替换了Base64字符映射表中的第62和63个字符。  
    “+”和“/”符号替换成了“-”和“_”符号。  
    但对于补位符“=”，一种建议是使用“~”符号，另一种建议是使用“.”符号。  
    Bouncy Castle的Url Base64算法实现与RFC 4648定义较为接近，构建定长Base64编码，使用“.”符号作为填充符。  
    Commons Codec的Url Base64算法实现遵照了RFC 4648绝大部分定义，为避免可能的错误，使用不定长Base64编码，抛弃了填充符。
4. Base64算法虽不能称为加密算法，但其变换法则遵从了单表置换算法。也正因如此，Base64算法成为加密算法学习最好的范例。  
    Base64算法常作为密钥、密文和证书的一种通用存储编码格式，与加密算法形影不离。
5. Bouncy Castle遵循的是一般Base64算法，也就是简单地根据Base64字符映射表做了编码转换。
6. 根据RFC 2045定义，每行为76个字符，行末加入一个回车换行符。  
    但并不是当每行够了76个字符才需要在行末加入一个回车换行符，每行不管够不够76个字符都要加入一个回车换行符。

## 第 6 章  验证数据完整性—消息摘要算法

1. 消息摘要算法主要分为三大类：  
    MD（Message Digest，消息摘要算法）；  
    SHA-1（Secure Hash Algorithm，安全散列算法）；  
    HmacMD5（Message Authentication Code，消息认证码算法）。
2. 消息摘要算法又称散列算法，其核心在于散列函数的单向性。  
    即通过散列函数可获得对应的散列值，但不可通过该散列值反推其原始信息。  
    消息摘要算法常用于验证数据的完整性，是数字签名算法的核心算法。  
    消息摘要算法对同一段数据做多次摘要处理后，其摘要值完全一致。因此，我们可以通过消息摘要的结果来判别消息内容是否一致。
3. 几乎每一种消息摘要算法都有大概三种实现方式：Sun、Bouncy Castle和Commons Codec。  
    Sun提供了最基本的算法实现；  
    Bouncy Castle在Sun的基础上做了扩展，实现了Sun未能提供的算法；  
    Commons Codec在Sun的基础上，对其方法做了封装，使其易用性提高，方便使用。
4. MD5算法常作为安全性要求不高的环境中的常用算法。  
    如果只要求MD5算法支持，Commons Codec是首选。  
    虽然MD5算法的破解使其安全性大为降低，但在用户注册/登录模块中仍然是架构师首选的方案。  
    各大软件厂商在其软件下载页面上仍然使用MD5算法作为数据完整性验证的首选方法。
5. SHA（Secure Hash Algorithm，安全散列算法）是消息摘要算法的一种，被广泛认可为MD5算法的继任者。  
    SHA与MD算法不同之处主要在于摘要长度，SHA算法的摘要更长，安全性更高。  
    若在应用中使用SHA系列算法，且不要求对SHA-224算法提供支持，Commons Codec是更为合适的选择。  
    如果只是需要在Sun原有SHA系列算法支持的基础上加入十六进制编码转换，Bouncy Castle和Commons Codec都是不错的选择。
6. 消息摘要长度与安全强度成正比。  
    从这一点来说，SHA系列算法比MD系列算法更具优势。  
    MD系列算法仅有128位，而SHA算法则可以从160位扩充到512位，更具安全性。  
    SHA算法较之MD算法更为安全，常常出现在一些安全系数要求较高的环境中。
7. 为了提高安全性，往往将一些其他的不可变信息，如用户名、Email地址加入原始密码中，使得密码破译的难度加大。  
    其中，不可变信息称为“盐”，而这种处理方式常称为“加盐处理”，其实就是对原始信息的一堆混淆。
8. MAC（Message Authentication Code，消息认证码算法）是含有密钥散列函数算法，兼容了MD和SHA算法的特性，并在此基础上加入了密钥。  
    经MAC算法得到的摘要值也可以使用十六进制编码表示，其摘要值长度与参与实现的算法摘要值长度相同。
9. CRC（Cyclic Redundancy Check，循环冗余校验）是可以根据数据产生简短固定位数的一种散列函数，主要用来检测或校验数据传输/保存后出现的错误。  
    生成的散列值在传输或储存之前计算出来并且附加到数据后面。  
    CRC-32算法仍是各种压缩算法中最为常用的数据完整性校验算法。  
    CRC-32算法仍广泛用于通信领域，实现差错控制，其变种Adler-32算法则广泛适用于zlib压缩算法中。  
    CheckedInputStream和CheckedOutputStream两个类，可用于输入输出流的冗余校验处理。  
    CRC-32算法是由CRC32类来实现的。  
    对于Adler-32算法，请使用Adler32类。

## 第 7 章  初等数据加密—对称加密算法

1. 对称加密算法易于理解，便于实现。  
    根据加密方式分为密码和分组密码；  
    分组密码工作模式又可分为ECB、CBC、CFB、OFB和CTR等；  
    密钥长度决定了加密算法的安全性。  
    对称加密算法提高数据安全性的同时带来了密钥管理的复杂性。
2. 在对称加密算法中：  
    DES算法最具有代表性，堪称典范；  
    DESede是DES算法的变种；  
    AES算法则作为DES算法的替代者；  
    而IDEA算法作为一种强加密算法，成为电子邮件加密软件PGP（Pretty Good Privacy）的核心算法之一。
3. DES算法和DESede算法统称DES系列算法。  
    DES算法是对称加密算法领域中的典型算法，为后续对称加密算法的发展奠定了坚实的基础。  
        DES算法有3点安全隐患：密钥太短、迭代偏少和半公开性。  
    DESede算法基于DES算法进行三重迭代，增加了算法安全性。  
        DESede算法将密钥长度增至112位或168位，抗穷举攻击的能力显著增强，但核心仍是DES算法，虽然增加迭代次数提高了安全性，但与此同时也造成处理速度较慢，密钥计算时间加长，加密效率不高的问题。
4. AES算法因密钥建立时间短、灵敏性好、内存需求低等优点，在各个领域得到广泛的研究与应用。  
    经过验证，目前采用的AES算法能够有效抵御已知的针对DES算法的所有攻击方法，如部分差分攻击、相关密钥攻击等。  
    至今，还没有AES破译的官方报道。
5. IDEA算法是目前较为常用的电子邮件加密算法之一。  
    IDEA算法在美国之外提出并发展起来，避开了美国法律上对加密技术的诸多限制。  
    IDEA算法使用长度为128位的密钥，数据块大小为64位。  
    从理论上讲，IDEA属于“强”加密算法，至今还没有出现对该算法的有效攻击算法（以目前计算机水平，破译一个IDEA密钥至少需要10^13年）。
6. PBE（Password Based Encryption，基于口令加密）算法是一种基于口令的加密算法。  
    其特点在于口令由用户自己掌管，采用随机数（这里我们叫做盐）杂凑多重加密等方法保证数据的安全性。  
    使用PBE算法对数据做加密/解密操作时，其实是使用了DES或AES等其他对称加密算法做了相应的操作。  
    PBE系列算法就是将这些算法进行合理组合，其密钥长度均以PBE具体算法中的对称加密算法密钥长度为准，其工作模式基本上为CBC模式。

## 第 8 章  高等数据加密—非对称加密算法

1. 相比与对称加密算法的单钥体系，非对称加密算法的双钥体系更为安全。  
    非对称加密的缺点是加解密速度要远远慢于对称加密，在某些极端情况下，非对称加密算法甚至比对称加密要慢1000倍。  
    针对非对称加密算法的低效问题，各密码学机构主张将对称加密算法与非对称加密算法相结合，使用对称加密算法为数据加密/解密，使用公钥和私钥为对称加密算法密钥加密/解密。  
    在实际应用中，我们很少会直接使用非对称加密算法进行数据加密。真正对数据进行加密的算法其实都是对称加密算法。非对称加密算法的主要职责是用来加密对称加密算法的秘密密钥。  
    利用对称加密算法的高效性，加之非对称加密算法的密钥管理，提升整体加密系统的安全性。  
    非对称加密算法通常配合数字证书、SSL/TLS协议构建单向认证或双向认证使用。
2. 虽然可以使用公钥对数据加密，但这种方式还是会存在一定的安全隐患。  
    如果要建立更安全的加密消息传递模型，就需要甲乙两方构建两套非对称加密算法密钥，仅遵循“私钥加密，公钥解密”的方式进行加密消息传递。
3. 基于DH算法实现的加密通信系统实际上是使用同一个秘密密钥完成相应的加密/解密对称加密系统。  
    作为对称加密体制向非对称加密体制的一种过渡，DH算法仅仅比一般的对称加密算法多了密钥对的构建和本地密钥的构建这两项操作，而真正的数据加密/解密操作仍由对称加密算法完成。  
    DH密钥交换算法的安全性基于有限域上的离散对数难题。  
    基于这种安全性，通过DH算法进行密钥分配，使得消息的收发双方可以安全地交换一个秘密密钥，再通过这个密钥对数据进行加密和解密处理。  
    完成甲乙方密钥的构建操作后，我们便可以完成本地密钥的构建。这里，要求使用不对称的公钥和私钥来构建本地密钥，即使用甲方私钥和乙方公钥构建甲方本地密钥；使用乙方私钥和甲方公钥构建乙方本地密钥。  
    合理选择密钥长度和对称加密算法是构建基于DH算法密码系统的关键。  
    Java 7对DH算法提供了完善的支持，并将DH算法实现作为后续非对称加密算法实现的基础。
4. ECC（Elliptical Curve Cryptography，椭圆曲线加密）算法以椭圆曲线理论为基础，在创建密钥时可做到更快、更小，并且更有效。  
    ECDH是基于椭圆曲线加密算法的密钥交换算法（这里将ECC简化为EC），密钥较短但密钥安全性更强，其原理与DH算法完全一致。  
    ECDH算法的密钥实际上也是EC算法的密钥，初始化密钥对生成器时，使用“EC”代替“ECDH”也可以。  
    ECDH算法对交换的密钥算法支持还不能像DH算法那样全面，作者尝试使用AES、DES和DESede算法构建本地密钥均告失败，但Blowfish、RC2和RC4都可以正常使用。  
    在Java 7中提供了基于椭圆曲线加密算法的密钥交换算法ECDH。
5. RSA算法是唯一被广泛接受并实现的通用公开加密算法，目前已经成为非对称加密算法的国际标准。  
    RSA算法基于大数因子分解难题，而ElGamal算法和ECC算法则是基于离散对数难题。  
    RSA算法既可用于数据加密也可用于数字签名。  
    Java 7提供了完善的RSA算法支持，通过Bouncy Castle可以扩充相应的填充方式。
6. ElGamal算法公钥和私钥长度几乎一致，基于Bouncy Castle加密组件的ElGamal算法实现仅遵循“公钥加密，私钥解密”的简单原则。  
    ElGamal的一个不足之处是它的密文会成倍扩张。

## 第 9 章  带密钥的消息摘要算法—数字签名算法

1. 数字签名算法是公钥基础设施（Public Key Infrastructure，PKI）以及许多网络安全机制（SSL/TLS、VPN等）的基础。  
    我们可以把数字签名算法近似看成是一种附加了公钥和私钥的消息摘要算法。  
    数字签名算法包含签名和验证两项操作，遵循“私钥签名，公钥验证”的签名/验证方式。签名时需要使用私钥和待签名数据，验证时则需要公钥、签名值和待签名数据，其核心算法主要是消息摘要算法。  
    数字签名算法要求能够验证数据完整性、认证数据来源，并起到抗否认的作用。  
    数字签名算法在实际运用时，通常是先使用消息摘要算法对原始消息做摘要处理，然后再使用私钥对摘要值做签名处理；验证签名时，则使用公钥验证消息的摘要值。  
    在实际应用中，很少会直接使用数字签名对数据进行签名/验证。并且，较少直接使用非对称加密算法对数据进行加密/解密。这些操作通常叫做底层操作，可配合数字证书、SSL/TLS协议构建单向认证或双向认证使用。
2. 数字签名算法主要包括RSA、DSA和ECDSA共3种算法。  
    RSA算法源于整数因子分解问题，DSA和ECDSA算法源于离散对数问题。
3. RSA算法既是非对称加密算法中的经典，同样也是数字签名算法中的经典。  
    在Java语言的世界里，对于RSA算法的支持是最为完整的。  
    RSA密钥长度默认1024位，密钥长度必须是64的倍数，范围在512～65536位之间。
4. DSS本质上是ElGamal数字签名算法，DSS使用的算法称为数字签名算法（Digital Signature Algorithm，DSA）。  
    DSA算法仅包含数字签名算法，使用DSA算法的数字证书无法进行加密通信，而RSA算法既包含加密/解密算法，同时兼有数字签名算法。  
    与RSA数字签名算法实现相比，DSA算法仅支持SHA系列的消息摘要算法。  
    DSA密钥长度默认为1024位，密钥长度必须是64的倍数，范围在512～1024位之间（含）。  
    DSA算法签名长度与密钥长度无关，但可能与待签名数据存在某种关联。  
    DSA算法实现是最为简单的数字签名算法，若仅需要使用数字签名算法，则DSA算法是不错的选择。
5. ECDSA算法相对于传统签名算法具有速度快、强度高、签名短等优点。  
    ECDSA算法密钥长度相比其他数字签名算法更短小，默认长度为256位，但安全性却更高。  
    ECDSA算法密钥的公钥长度略小于私钥。

## 第 10 章  终极武器—数字证书

1. 数字证书集合了多种密码学算法：  
    自身带有公钥信息，可完成相应的加密/解密操作；  
    同时，还带有数字签名，可鉴别消息来源；  
    且自身带有消息摘要信息，可验证证书的完整性；  
    由于证书本身含有用户身份信息，因而具有认证性。  
    OSI参考模型五类安全服务除访问控制服务外，均可通过数字证书实现。
2. 数字证书（Digital Certificate）也称为电子证书，类似于我们生活中的身份证，用于标识网络中的用户（计算机）身份。  
    在现实生活中，我们的身份证需由公安机关的签发，而网络用户（计算机）的身份凭证则需由数字证书颁发认证机构（Certificate Authority，CA）签发，只有经过CA签发的证书在网络中才具备可认证性。  
    数字证书为发布公钥提供了一种简便的途径，其数字证书则成为加密算法以及公钥的载体。  
    依靠数字证书，我们可以构建一个简单的加密网络应用平台。
3. 证书的签发过程实际上是对申请数字证书的公钥做数字签名，证书的验证过程实际上是对数字证书的公钥做验证签名，其中还包含证书有效期验证。
4. 目前，数字证书中最为常用的非对称加密算法是RSA算法，与之配套使用的签名算法是SHA1withRSA算法，而最为常用的消息摘要算法是SHA1算法，
5. 数字证书有多种文件编码格式，主要包含CER编码、DER编码等：  
    DER使用定长模式，而CER使用变长模式。
6. PKCS（Public-Key Cryptography Standards，公钥加密标准）由RSA 实验室和其他安全系统开发商为促进公钥密码的发展而制定的一系列标准。
7. 密钥库文件目前主要有JKS和PEM两种编码格式文件。  
    可以通过PKCS#12格式的证书文件在两种格式的密钥库中进行库文件导出/导入等。  
    通常使用Base64编码格式作为数字证书文件存储格式。
8. 在实际应用中，很多数字证书都属于自签名证书，即证书申请者为自己的证书签名。  
    这类证书通常应用于软件厂商内部发放的产品中，或约定使用该证书的数据交互双方。  
    数字证书完全充当加密算法的载体，为必要数据做加密/解密和签名/验证等操作。
9. 数字证书的最佳应用环境是在HTTPS安全协议中，使用流程远比上述加密交互流程复杂，但相关操作封装在传输层，对于应用层透明。  
    在HTTPS安全协议中使用非对称加密算法交换密钥，使用对称加密算法对数据进行加密/解密操作，提高加密/解密效率。
10. 任何机构或个人都可以申请数字证书，并使用由CA机构颁发的数字证书为自己的应用保驾护航。  
    要获得数字证书，我们需要使用数字证书管理工具（如KeyTool和OpenSSL）构建CSR（Certificate Signing Request，数字证书签发申请），交由CA机构签发，形成最终的数字证书。
11. KeyTool是Java中的数字证书管理工具，用于数字证书的申请、导入、导出和撤销等证书管理操作。  
    KeyTool与本地密钥库相关联，将私钥存于密钥库，公钥则以数字证书输出。  
    KeyTool工具支持RSA和DSA共2种算法，且DSA算法为默认算法。  
    目前，Java 7仅支持X.509类型的数字证书。
12. OpenSSL（`http://www.openssl.org/`）是一个开放源代码软件包，由Eric A. Young 和 Tim J. Hudson等人编写，实现了SSL及相关加密技术，是最常用的证书管理工具。  
    OpenSSL通常使用PEM（Privacy Enbanced Mail，隐私增强邮件）编码格式保存私钥。  
    为了解析PEM文件获取密钥对，我们可以使用BouncyCastale提供的相关实现。  
    PFX文件由OpenSSL产生，可通过KeyTool导入至JKS密钥库/信任库中，由此完成密钥库的统一。
13. 密钥库管理私钥，数字证书管理公钥，私钥和公钥分属消息传递两方，进行加密消息传递。  
    因此，我们可以将密钥库看做私钥相关操作的入口，数字证书则是公钥相关操作的入口。

## 第 11 章  终极装备——安全协议

1. HTTPS（Hypertext Transfer Protocol over Secure Socket Layer）协议是Web上最为常用的安全访问协议。  
    HTTPS协议实际上是基于SSL/TLS的HTTP协议，位于应用层，简单地说，HTTPS=HTTP+SSL/TLS。  
    HTTPS协议为数字证书提供了最佳的应用环境。  
    受限于手机及手持设备的处理和存储能力，使用了简化的WTLS（Wireless Transport Layer Security，无线传输层安全）协议。
2. SSL/TLS协议包含两个协议：  
    SSL（Secure Socket Layer，安全套接字层）和TLS（Transport Layer Security，传输层安全）协议。SSL共有3个版本：SSL1.0、SSL2.0和SSL3.0。  
    IETF在基于SSL3.0协议的基础上发布了TLS1.0、TLS1.0与SSL3.0几乎是兼容的。  
    通常意义上我们提到的SSL/TLS协议指的是SSL3.0或TLS1.0的网络传输层安全协议。  
    SSL/TLS协议通过使用数字证书确保网络交互安全，为数字证书的使用提供了最佳的应用环境。  
    SSL/TLS协议利用密码学算法在互联网上提供端点身份认证和通信保密，完全基于PKI，有较高的安全性。
3. 单向认证服务和双向认证服务是网络交互平台中最高级别的安全服务，广泛应用于电子商务等领域。  
    单向认证服务：仅需要服务器端服务器提供证书，验证服务器身份。  
    双向认证服务：需要服务器提供服务器证书的前提下，要求客户端提供客户证书，同时验证服务器和客户身份。
4. 单向认证服务实现不需要实现任何代码，我们仅需要对Tomcat做细微调整，完成HTTPS协议配置和密钥库配置，即可完成服务构建工作。  
    server.xml文件位于Tomcat的conf目录中

    ```code
        <Connector
            port="443"
            SSLEnabled="true"
            clientAuth="false"
            maxThreads="150"
            protocol="HTTP/1.1"
            scheme="https"
            secure="true"
            sslProtocol="TLS"
            keystoreFile="conf/zlex.keystore"
            keystorePass="123456" />
    ```

    为使得HTTPS协议配置生效，我们需要将密钥库文件参数keystoreFile指向密钥库文件，并设定密钥库密码参数keystorePass，密钥库类型参数keystoreType默认值为“JKS”。  
    如果不显示配置信任库参数，信任库文件参数truststoreFile默认将指向密钥库文件，信任库密码参数truststorePass默认指向密钥库密码，信任库类型参数truststoreType默认值为“JKS”。  
    这里我们需要注意客户端验证参数clientAuth，当前默认值为“false”。构建双向认证服务时需将其置为“true”，并修改密钥库参数和信任库参数。  
    原有配置指定端口参数port为8443，而HTTPS协议绑定的端口是443，我们可以将其改为443，而无需通过端口访问HTTPS。
5. 不同的客户端同一时间访问同一服务时，将有可能使用不同的协议或算法，唯一可以确定的是通过数字证书确定的非对称加密算法。
6. 双向认证服务实现同样不需要实现任何代码，与单向认证服务构建几乎毫无差别。  
    双向认证服务需要根证书、服务器证书和客户证书共3项证书。

    ```code
        <Connector
            SSLEnabled="true"
            clientAuth="true"
            maxThreads="150"
            port="443"
            protocol="HTTP/1.1"
            scheme="https"
            secure="true"
            sslProtocol="TLS"
            keystoreFile="conf/server.p12"
            keystorePass="123456"
            keystoreType="PKCS12"
            truststoreFile="conf/ca.p12"
            truststorePass="123456"
            truststoreType="PKCS12" />
    ```

    与单向认证服务配置不同，双向认证服务区分信任库文件和密钥库文件。此时，server.p12文件将作为密钥库文件，而ca.p12文件则作为信任库文件。  
    在上述配置中，我们将客户端验证参数clientAuth的值置为“true”，这是打开双向认证的关键一步。
7. 在Java环境中有密钥库和信任库之分。  
    密钥库存储自身的密钥、证书等信息；  
    而信任库存储来自外界的数字证书等信息。  
    当甲乙双方完成自身密钥库初始化工作后，如果导入了对方的数字证书，双方就具备了互信的条件，也就可以构建双向认证服务了。

## 第 12 章  量体裁衣—为应用选择合适的装备

1. 在设计系统时，我们需要注意合理隐蔽用户的私密信息，尽量避免敏感信息在系统中直接暴露。  
    如果仅仅将密码以明文的方式存储在数据库中，任何拥有数据库访问权限的人都可以获得某个用户的访问权限。  
    用户密码通常以摘要值的方式存储在数据库中。  
    MD5算法的摘要值为32位十六进制字符串，SHA1算法的摘要值为40位十六进制字符串。  
    所谓加盐处理，就是在原有材料中加入其他成分（盐），增加系统复杂度。对于我们现在讨论的话题，“盐”必须是一种用户自有且不可变的元素。  
    当用户遗失密码时，由系统根据随机信息重置密码，并以邮件方式告知用户新密码。
2. 想要真正加强数据的机密性，对称加密算法是我们的首选。  
    在实际应用中，类似于这样的网络交互系统几乎都采用了对称加密算法对数据进行加密。  
    这些系统通常用于传递聊天消息，甚至是传递对账数据。
3. Web Service应用基于明文协议（WSDL、SOAP协议等），是最为常用的数据交互应用系统，配合使用单向认证或双向认证可以确保数据的机密性、认证性。  
    使用数字证书构建SSL/TLS协议，最终构建HTTPS服务是保护Web Service系统的最佳方案。  
    如果数据的交互双方需要使用非对称加密算法对数据加密，不如使用SSL/TLS协议并配合数字证书完成数据加密交互。
4. 非对称加密算法通常配合数字证书使用，并以数字证书作为公钥的载体，用于数据加密/解密以及数字签名/验证。  
    这种基于数字证书的应用通常应用在基于C/S结构的网络应用中。  
    如今炒得火热的移动应用是标准的基于C/S结构的网络应用。  
    手机软件作为客户端，可以捆绑数字证书与服务器进行加密交互。
