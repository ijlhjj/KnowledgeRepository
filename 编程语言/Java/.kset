0、Java语言规范：
    Java区分大小写；
    Java语句必须以分号结束；
    /* */ 注释不能嵌套；
    整型的范围与运行Java代码的机器无关；
    整型值和布尔值之间不能进行相互转换；
    Java支持三元操作符： condition ?  exp1 : exp2
    构造器总是与类同名；
    在实例方法中，关键字this指示隐式参数（即当前操作对象）；
    Java方法总是采用按值调用传递参数；
    实例字段可以和方法同名（record同名访问器）；
    枚举和记录不支持继承。枚举和记录可以实现接口，但不能扩展类（因为它们隐式地扩展了Record和Enum类）；
    
0、Java编程风格：
    变量的声明尽可能地靠近变量第一次使用的地方；
    将实例字段定义为私有的（private修饰）；
    局部变量不要与实例变量同名；
    使用类名调用静态方法（不要使用对象调用）；
    类注释必须放在import语句之后，class定义之前；
    谨慎使用受保护字段（protected修饰）；
    建议为每一个自定义类都添加toString方法；
    建议不要提供冗余的关键字；

1、Java命名规范：
    名称必须以字母开头，后面可以跟字母和数字的任意组合，长度基本上没有限制，但是不能使用Java保留字。
        需要注意，与大多数程序设计语言相比，Java中“字母”和“数字”的范围更大。
            字母包括 'A'~'Z' 、 'a'~'z' 、 '_' 、 '$' 或在某种语言中表示字母的任何Unicode字符；
            数字包括 '0'~'9' 和在某种语言中表示数字的任何Unicode字符；
    类名是以大写字母开头的名词。如果名字由多个单词组成，应该采用驼峰命名法。
    常量名使用全大写，多个单词之间以下划线分隔。

    如果想要知道标识符中可以使用哪些Unicode字符，可以使用Character类的isJavaIdentifierStart和isJavaIdentifierPart方法来检查。
    尽管'$'是一个合法的标识符字符，但不要在你自己的代码中使用这个字符。它只用于Java编译器或其他工具生成的名字。

1、安装JDK注意事项:
    安装路径最好不要包含空格；（比如Windows系统的默认安装路径“C:\Program Files\Java”就包含空格）
    安装完成后添加PATH环境变量设置；（Windows和Linux系统需要，macOS不需要）
    不要设置CLASSPATH环境变量！！！（这个环境变量只在一些老的JDK版本中才需要设置）
    使用 javac --version 验证安装完成；（java有时不需要设置环境变量也可以执行，javac必须设置环境变量才能执行）

1、Object类：
    Object类是Java中所有类的始祖，Java中的每一个类都扩展了Object；
    所有的数组类型（不管是对象数组还是基本类型的数组）都扩展了Object类的类类型；
    Object类中的equals方法用于检测一个对象是否等于另一个对象。Object类中实现的equals方法将确定两个对象引用是否相同。这是一个合理的默认行为：如果两个对象相同，则这两个对象肯定就相等；
    为了防备变量可能为null的情况，可以使用Objects.equals方法进行检测；
    对于数组类型，可以使用Arrays.equals方法检查相应的数组元素是否相等。对于多维数组，可以使用Arrays.deepEquals方法；
    可以使用Arrays.hashCode方法计算散列码，这个散列码由数组元素的散列码组成；
    hashCode方法应该返回一个整数（可以是负数）。要合理地组合实例字段的散列码，使得不同对象的散列码尽量分散开；
    需要组合多个散列值时，可以使用Objects.hash方法；
    equals与hashCode的定义必须相容：如果 x.equals(y)==true，则 x.hashCode()==y.hashCode() ；

    Java语言规范对equals方法提出的要求：（可参考utils中的Person类实现）
        1、自反性：对于非null引用，x.equals(x)返回true；
        2、对称性：x.equals(y)==y.equals(x)；
        3、传递性：x.equals(y)返回true，y.equals(z)返回true，则x.equals(z)返回true；
        4、一致性：如果x和y引用的对象没有发生变化，反复调用x.equals(y)应该返回相同结果；
        5、对于非null引用x,x.equals(null)应该返回false；
    如果子类中重写equals方法，应该优先调用父类的equals方法：super.equals(other)；

1、Java是一种强类型语言。这意味着必须为每一个变量声明一种类型。
    在Java中，只有基本类型不是对象，一共有 8 种基本类型：
        所有基本类型都有一个与之对应的包装器类，包装器类是不可变的。
        整型用于表示没有小数部分的数值，允许是负数。浮点类型用于表示有小数部分的数值。
        所有的浮点数值计算都遵循 IEEE754 规范。
        类型        存储需求            取值范围
        int         4字节       -2147483648 ~ 2147483647
        short       2字节       -32768 ~ 32767
        long        8字节       -9223372036854775808 ~ 9223372036854775807
        byte        1字节       -128 ~ 127
        float       4字节       大约 ±3.40282347E+38F(有效位数为 6 ~ 7 位)
        double      8字节       大约 ±1.79769313486231570E+308(有效位数为 15 位)
        char        2字节       \u0000 ~ \uFFFF
        boolean                 true / false

1、Java并不只是一种语言，Java是一个完整的平台，有一个庞大的库，其中包含了很多可重用的代码，以及一个提供诸如安全性、跨操作系统的可移植性以及自动垃圾收集等服务的执行环境。
2、Java“白皮书”的关键术语：
    Java“白皮书”：  https://www.oracle.com/java/technologies/language-environment.html
    11个关键术语：  https://horstmann.com/corejava/java-an-overview/7Gosling.pdf
3、模块是提供一个特定功能的自包含的代码单元。
4、程序设计语言的成功更多地取决于其支撑系统的能力，而不是语法的精巧性。Java的成功源于其类库能够让人们轻松地完成原本有一定难度的事情。
5、Java9引入的JShell程序提供了一个“读取——评估——打印 循环”（Read-Evaluate-Print Loop, REPL）。
6、源代码的文件名必须与公共类的名字相同，并用 .java 作为扩展名。这表明一个文件中最多只能有一个以 public 修饰的类。
    一个源文件中最多只能有一个公共类（也可以没有），但可以有任意数目的非公共类；
7、如果 main 方法正常退出，那么Java应用程序的退出码为 0，表示成功地运行了程序。如果希望在终止程序时返回其他的退出码，那就需要使用 System.exit 方法。
8、与大多数程序设计语言一样，Java中的注释也不会出现在可执行程序中。因此，可以在源程序中根据需要添加任意多的注释，而不必担心可执行代码会膨胀。
9、数值计算说明：
    不同类型数值计算时会进行类型的向上转换，所以计算中包含double类型时会全部转换为double类型进行计算；
    当参与 / 运算的两个操作数都是整数时，表示整数除法，否则，表示浮点除法；
    整型类型除以0会抛出异常；
    浮点类型除以0时：正数结果为 Infinity，负数结果为 -Infinity，0为 NaN ；
    浮点类型负数的平方根为 NaN；
    所有 NaN 的值都认为是不相同的，即 NaN != NaN 。检测非数时应该使用 Double.isNaN 方法；
    在Java17中，再次要求虚拟机完成严格的64位运算，strictfp关键字现在已经过时了；
    数学规则中余数总是要 ≥0 ，但在Java中，要特别注意负数求余的情况；

10、浮点数值不适用于无法接受舍入误差的金融计算，金融计算应该使用 BigDecimal 类。
    System.out.println(2.0 - 1.1) 将打印出 0.8999999999999999，而不是人们期望的0.9.这种舍入误差的主要原因是浮点数值采用二进制系统表示，而在二进制系统中无法精确地表示分数 1/10 ，这就好像十进制无法精确地表示分数 1/3 一样。
    在检测两个浮点数是否相等时需要格外小心。
11、转义序列 \u 还可以出现在加引号的字符常量或字符串之外（而其他所有转义序列不可以）。Unicode转义序列会在解析代码之前得到处理。
12、在Java中，char类型描述了UTF-16编码中的一个代码单元。UTF-16编码采用不同长度的编码表示所有Unicode码点。在基本多语言平面中，每个字符用16位表示，通常称为代码单元；而辅助字符编码为一对连续的代码单元。
    建议不要在程序中使用char类型，除非确实需要处理UTF-16代码单元。最好将字符串作为抽象数据类型处理。
13、在Math类中，为了达到最佳的性能，所有的方法都没有使用精确计算。如果得到一个完全可预测的结果比运行速度更重要的话，那么就应该使用StrictMath类，确保在所有平台上得到相同的结果。
14、Math类提供了一些方法使整数有更好的运算安全性。如果一个计算溢出，数学运算符只是返回错误结果而不做任何提醒，Math类的方法则会抛出一个异常。
15、Math.floorMod 方法为了解决有关整数求余的问题： floorMod( position + adjustment, 12) 总会得到一个 0~11 之间的数。（遗憾的是，对于负除数，floorMod会得到负数结果，不过这种情况在实际中不常出现。）
16、强制类型转换通过截断小数部分将浮点值转换为整型。如果想对浮点数进行舍入运算，需要使用 Math.round 方法。
17、如果试图将一个数从一种类型强制转换为另一种类型，而又超出了目标类型的表示范围，结果就会是一个完全不同的值。例如，(byte)300 实际上会得到44 。
18、 && 和 || 运算符按照“短路”方式求值； & 和 | 运算符按照“非短路”方式求值。
19、Java14引入了switch表达式：
    switch表达式优于语句；
    switch表达式的关键是生成一个值（或者产生一个异常而失败），所以每个分支必须生成一个值；
    使用整数或String操作数的switch表达式必须有一个default分支。因为不论操作数值是什么，这个表达式都必须生成一个值，而case分支不可能覆盖这两种操作数的所有值；
    如果操作数为null，会抛出一个NullPointerException；
    如果case以箭头 -> 结束，则没有直通行为；如果case以冒号结束，则有直通行为（不遇到break就接着执行下一个分支的行为）。不能在一个switch语句中混合使用冒号和箭头；
    switch表达式中的yield关键字与break类似，但与break不同的是yield还会生成一个值；
    不允许“跳出”switch表达式。具体来讲，不能在switch表达式中使用return、break或continue语句。
20、String字符串：
    String类对象是“不可变的”(immutable)；
    从概念上讲，Java字符串就是Unicode字符序列；
        Java字符串是一个char值序列；
        length方法将返回采用UTF-16编码表示给定字符串所需要的代码单元个数。一个辅助字符的length是2 。
    虚拟机不一定把字符串实现为代码单元序列。在Java9中使用了一个更紧凑的表示。只包含单字节代码单元的字符串使用byte数组实现，所有其他字符串使用char数组；
    如果虚拟机始终将相同的字符串共享，就可以使用 == 运算符检测是否相等。但实际上只有字符串字面量是共享的，而 + 或 substring 等操作得到的字符串并不共享。因此，千万不要使用 == 运算符测试字符串的相等性；
    strip...()方法删除头部或尾部的空白符。trim()方法删除小于等于U+0020的字符；
    StringBuffer类的效率不如StringBuilder类，不过它允许采用多线程的方式添加或删除字符。在方法内一般应该使用StringBuilder类；
    String.format静态方法创建一个格式化的字符串，Java15添加了formatted方法实现了同样的功能；

21、Java15新增了文本块特性，类似于Python的多行文本。
    一般不用对引号进行转义；
    行尾的 \ 会把这一行与下一行连接起来；
    不作连接符使用的反斜线都需要转义；
    文本块会对行结束符进行标准化，删除末尾的空白符，并把Windows的行结束符（\r\n）改为简单的换行符（\n）；
    尽管不太可能，不过假如确实需要保留末尾的空格，这种情况下可以把最后一个空格转换为一个 \s 转义序列；
    去除缩进过程中不考虑空行；
    结束符"""前面的空白符与其他行空白符的差值决定了实际的缩进；
    要当心缩进文本块的公共前缀中混用制表符和空格的情况，不小心漏掉一个空格很容易得到一个缩进错误的字符串；
22、因为输入对所有人都可见，所以Scanner类不适用于从控制台读取密码。可以使用Console类来达到这个目的。为安全起见，将返回的密码存放在一个字符数组中，而不是字符串中。完成对密码的处理后，应该马上填充覆盖数组元素。
23、Java的printf格式化输出方法沿用了C语言库函数的约定。
24、在进行文件输入输出时，最好指定文件的字符编码，否则在不同的机器上运行有可能使用机器的“默认编码”，这在不同的机器上可能会有不同的表现。
25、break和continue语句可以用来改变程序的执行流程。可以使用带标签的break语句跳出多层循环，continue语句也可以结合标签使用来改变执行流程；
26、BigInteger类实现任意精度的整数运算，BigDecimal类实现任意精度的浮点数运算。
    对于BigDecimal类，总是应当使用带一个字符串参数的构造器。还有一个BigDecimal(double)构造器，不过这个构造器本质上很容易产生舍入误差；
    RoundingMode.HALF_UP是我们常用的四舍五入舍入模式；
27、数组：
    数组存储相同类型值的序列；
    一旦创建了数组，就不能再改变它的长度；
    允许有长度为0的数组，它与null并不相同；
    数组在进行初始化之前是不能使用的；
    创建一个数组时，数值数组元素初始化为0，boolean数组元素初始化为false，对象数组元素初始化为null；
    Arrays工具类包含了大量操作数组的方法；
    Java实际上没有多维数组，只有一维数组。多维数组被解释为“数组的数组”；
28、在Java中，任何对象变量的值都是一个引用（对象变量并不实际包含一个对象），指向存储在另外一个地方的某个对象。
29、Java10新增了var关键字来声明局部变量。
30、一个类的方法可以访问这个类的所有对象的私有数据。
31、System.setOut方法可以修改final变量的值，原因在于setOut方法是一个原生方法，而不是在Java语言中实现的。原生方法可以绕过Java语言的访问控制机制。这是一种特殊的解决方法，你自己编写程序时不要模仿这种做法。
32、工厂方法构造对象有两个好处：
    不能有参数相同的两个构造器，但工厂方法可以用不同的名字来区分，生成参数相同但构造过程不同的两个实例；
    构造器只能生成当前类对象，但工厂方法可以返回当前类的子类对象；
33、方法签名包括方法名以及方法参数，返回类型不是方法签名的一部分。如果多个方法有相同的方法名和不同的方法参数（包括参数个数不同、类型不同等），这叫做方法重载。
34、类的字段（包括静态字段和实例字段）在初始化时将自动设置为默认值：数值设置为0，布尔值为false，对象引用为null 。
35、在构造器中，可以使用this调用同一个类中的另一个构造器，可以使用super调用父类的构造器，但this调用和super调用都必须位于第一行，所以它们不能同时使用。
36、在类中可以包含任意个初始化块，它们会在执行构造器之前按定义顺序执行。
37、JDK17提供了多种强算法实现的随机数包，其中“L64X128MixRandom”算法对大多数应用都适用。
38、从JDK9开始，finalize方法已经被废弃。
39、JDK16新增了记录，记录（record）是一种特殊形式的类，其状态不可变，而且公共可读。
    记录自动生成“标准构造器”，如果要自定义构造器，建议使用“简洁形式”；
    记录自动生成访问器方法；
    记录自动生成toString、equals和hashCode方法；
    可以自定义覆盖自动生成的方法（方法签名一致即可）；
    记录可以有静态字段；
    记录不能增加实例字段；
    记录可以有静态方法和实例方法；
    记录的实例字段自动为final，但它们可能引用可变对象；
    记录更易读、更高效，而且在并发程序中更安全；
    
    对于完全由一组变量表示的不可变数据，要使用记录而不是类。如果数据是可变的，或者数据表示可能随时间改变，则使用类。
40、使用包的主要原因是确保类名的唯一性。
    从编译器的角度来看，嵌套的包之间没有任何关系，每一个包都是独立的类集合；
    使用 .* 的语法导入包下所有类对代码规模没有任何负面影响。它只是提供一个查找路径，不是类似 #include 的方式；
    只能使用星号（*）导入一个包，不能使用类似 *.* 的语法；
    在包中定位类是编译器的工作。类文件中的字节码总是使用完整的包名来引用其他类；
    import语句唯一的好处是简洁；
    可以使用import导入静态方法和字段；
    因为完全限定类名必须是唯一的，所以import语句的次序并不重要；
    在默认情况下，包不是封闭的实体，任何人都可以向包中添加更多的类；
    从JDK1.2开始时，类加载器明确禁止加载包名以 “java.” 开头的用户自定义类；
    用户自定义包无法受到类加载器保护，如果需要应当使用模块封装包（JDK9以上）；
41、Java编译器处理文件（文件分隔符和.java扩展名），而Java解释器加载类（使用.分隔符）。
42、类路径是所有包含类文件的路径的集合。
    可以为JAR文件目录指定一个通配符（在UNIX中，* 必须转义以防止shell扩展）（JDK6以上）；
    javac编译器总是在当前目录中查找文件，但只有当类路径中包含 “.” 目录时，Java虚拟机才会查看当前目录；
    利用 -classpath 选项设置类路径是首选的方法，另一种方法是通过设置CLASSPATH环境变量来指定类路径。具体细节依赖于所使用的shell；
    启动程序的整个指令必须写在一行中。将这样一个很长的命令行放在一个shell脚本或一个批处理文件中比较合适；
43、清单文件被命名为 MANIFEST.MF，它位于JAR文件的一个特殊的 META-INF 子目录中。
    清单文件的最后一行必须以换行符结束。否则，将无法正确地读取清单文件；
44、常用的Windows打包工具有Launch4J和IzPack 。
45、从Java9开始，Java工具开始转向一种更常用的选项格式，多字母选项名前面加两个短横向，另外对于常用的选项可以使用单字母快捷方式。（可参见JEP293）
46、类设计技巧：
    一定要保证数据私有；
    一定要初始化数据。最好不要依赖于系统的默认值，而是应该显式地初始化所有变量；
    不要在类中使用过多的基本类型；
    不是所有的字段都需要单独的字段访问器和更改器；
    分解有过多职责的类；
    类名和方法名要能够体现它们的职责；
    优先使用不可变的类；
47、super只是一个指示编译器调用超类方法的特殊关键字。这与this是不同的，this是对当前对象的引用，但super不是对父类对象的引用。
48、一个对象变量可以指示一个继承体系中的多种实际类型，这称为多态。
    虚拟机知道变量引用的实际对象类型，在运行时能够自动的调用正确的方法，这称为动态绑定；
    在Java中，动态绑定是默认的行为；
    动态绑定有一个非常重要的特性：无须修改现有的代码就可以对程序进行扩展；
    对象变量是多态的，一个Employee类型的变量既可以引用一个Employee类型的对象，也可以引用Employee类的任何一个子类的对象；
49、由一个公共超类派生出来的所有类的集合称为继承层次结构。在继承层次结构中，从某个特定的类到其祖先的路径称为该类的继承链。
50、有一个简单的规则可以用来判断是否应该将数据设计为继承关系，这就是 “is-a” 规则，它指出子类的每个对象也是超类的对象。
    “is-a” 规则的另一种表述是替换原则，它指出程序中需要超类对象的任何地方都可以使用子类对象替换。
51、在Java中，子类引用数组可以转换成超类引用数组，而不需要使用强制类型转换。
    为了确保不发生ArrayStoreException，所有数组都要牢记创建时的元素类型，并负责监督仅将类型兼容的引用存储到数组中。
52、准确地理解如何在对象上应用方法调用非常重要。
    编译器查看对象的声明类型和方法名。编译器将会一一列举X类中所有名为f的方法和其超类中所有名为f而且可访问的方法（超类的私有方法不可访问）；
    编译器要确定方法调用中提供的参数类型。如果在所有名为f的方法中存在一个与所提供参数类型完全匹配的方法，就选择这个方法。这个过程称为重载解析；
    如果是private方法、static方法、final方法或者构造器，那么编译器可以准确地知道应该调用哪个方法。这称为静态绑定；
    与此对应的是，如果要调用的方法依赖于隐式参数的实际类型，那么必须在运行时使用动态绑定；
    每次调用方法都要完成这个搜索，时间开销相当大。因此，虚拟机预先为每个类计算了一个方法表，其中列出了所有方法的签名和要调用的实际方法；
53、方法支持协变返回类型。
54、在覆盖一个方法的时候，子类方法不能低于超类方法的可见性。
55、final修饰的类不能被继承，final修饰的方法不能被重写。
    将类或方法声明为final只有一个原因：确保它们不会在子类中改变语义。
56、进行强制类型转换的唯一原因是：要在暂时忘记对象的实际类型之后使用对象的全部功能。
57、强制类型转换：
    只能在继承层次结构内进行强制类型转换；
    在将超类强制转换成子类之前，应该使用instanceof进行检查；
    如果x为null，x instanceof C 返回false；
    一个未捕获的ClassCastException异常就会导致程序终止；
    一般情况下，最好尽量少用强制类型转换和instanceof操作符；
    在JDK16中，引入了instanceof“模式匹配”，当instanceof模式引入一个变量时，可以立即在同一个表达式中使用这个变量；
58、Java的4个访问控制修饰符：
    private             仅本类可以访问
    public              可由外部访问
    protected           本包和所有子类可以访问
    默认（没有修饰符）  本包中可以访问
59、集合类：
    ArrayList
        数组列表管理着一个内部的对象引用数组；
        只有当数组列表的大小大于i时，才能够调用list.set(i, x) ；
        ArrayList插入和删除元素的效率很低。经常需要在中间插入和删除操作应该使用链表；
        由于每个值分别包装在一个对象中，所以 ArrayList<Integer> 的效率远远低于 int[] 数组；

60、在与遗留的代码交互时，要研究编译器的警告，确保这些警告不太严重。一旦确保问题不太严重，可以用 @SuppressWarnings("unchecked") 注解来标记接受强制类型转换的变量。
61、包装器类：
    自动装箱规范要求boolean、byte、char（<=127），介于 -128和127 之间的short和int包装到固定的对象中；
    不要用 == 比较包装器对象；
    不要使用包装器对象作为锁；       ？
    不要使用包装器类的构造器，它们已被弃用，并将被完全删除；
    装箱和拆箱是编译器的工作，而不是虚拟机。编译器生成类的字节码时会插入必要的方法调用。虚拟机只是执行这些字节码；
    包装器类是final修饰的不可变类，这意味着一旦生成包装器对象，包含在其中的值就不会再发生改变；
62、方法的最后一个参数可以是使用 省略号（...） 修饰的可变参数。
    允许将数组作为最后一个参数传递给有可变参数的方法。
63、抽象类：
    包含抽象方法的类必须被声明为抽象类；
    抽象类可以不包含抽象方法；
    抽象类可以包含字段和具体方法；
    抽象类不能实例化；
64、编译器只允许调用在类中声明的方法。
65、枚举是一种类类型，所有枚举类都是Enum的子类。
    枚举的构造器总是私有的，可以省略private修饰符。构造器只是在构造枚举常量的时候调用；
    Enum类有一个类型参数；
    可以使用 == 来直接比较枚举类型；
    如果需要的话，可以为枚举类型增加构造器、方法和字段；
66、Java17最终引入了密封类，密封类会控制哪些类可以继承它。
    如果试图定义一个未经允许的子类，将会发生错误；
    密封类可以准确地描述领域约束；
    一个密封类允许的子类必须是可访问的。它们不能是嵌套在另一个类中的私有类，也不能是位于另一个包中的包可见的类；
    对于允许的公共子类，规则要更为严格。它们必须与密封类在同一个包中。不过，如果使用模块，则必须在同一个模块中；
    使用密封类的一个重要原因是编译时检查；
    密封类的子类必须指定它是sealed、final，还是允许继续派生子类。对于允许派生子类，必须声明为non-sealed ；
    non-sealed关键字是第一个带连字符的Java关键字；
    密封接口与密封类完全相同，会控制直接子类型；
67、在程序运行期间，Java运行时系统始终为所有对象维护一个运行时类型标识。这个信息会跟踪每个对象所属的类。虚拟机利用运行时类型信息选择要执行的正确方法。
68、异常有两种类型：检查型异常（checked）和非检查型异常（unchecked）。
    对于下标越界和访问null引用等常见的非检查型异常，你应该集中精力避免这些错误的发生，而不是为它们编写错误处理；
    不是所有的错误都是可以避免的。如果竭尽全力还是可能发生异常，大多数Java API都会抛出一个检查型异常；
69、Java数组会记住每个元素的类型，即创建数组时new表达式中使用的元素类型。将一个Employee[]临时转换成Object[]数组，然后再把它转换回来是可以的，但一个从开始就是Object[]的数组却永远不能转换成Employee[]数组。
70、整型数组类型int[]可以转换为一个Object，而不是转换成对象数组。
71、继承的设计技巧：
    将公共操作和字段放在超类中；
    不要使用受保护的字段；
        protected机制并不能提供太多保护，这有两方面的原因：
            第一，任何一个人都能够由你的类派生一个子类，然后编写代码直接访问protected实例字段，从而破坏封装性；
            第二，同一个包中的所有类都可以访问protected字段，而不论它们是否为这个类的子类。任何人都可以在同一个包中增加一个新类；
        不过，有些方法不打算作为通用方法，要在子类中重新定义，protected方法对于指示这种方法可能很有用；
    使用继承实现 “is-a” 关系；
    除非所有继承的方法都有意义，否则不要使用继承；
    覆盖方法时，不要改变预期的行为；
        替换原则不仅应用于语法，更重要的是，它也适用于行为。覆盖一个方法的时候，不应该毫无缘由地改变它的行为；
        归根结底，关键在于在子类中覆盖方法时，不要偏离最初的设计初衷；
    使用多态，而不要使用类型信息；
    不要滥用反射；
        反射机制对于系统编程及其有用，但是通常并不适合编写应用程序；
        反射很脆弱；
72、接口：
    在Java中，接口不是类，而是对希望符合这个接口的类的一组需求；
    接口用来描述类应该做什么，而不指定它们具体应该如何做；
    使用接口的主要原因在于：Java是一种强类型语言。调用方法时，编译器要能检查这个方法确实存在；
    接口中的所有方法都自动是public方法，不过，实现接口时，必须显式把方法声明为public；
    接口中的字段总是 public static final ，可以定义常量，但不能定义实例字段；
    接口可以有静态方法；
    为接口增加方法可以做到“二进制兼容”；     ？
    在Java9中，接口中可以有private静态方法和实例方法。由于私有方法只能在接口本身的方法中使用，所以它们的用途很有限，只是作为接口中其他方法的辅助方法；
    接口可以提供多重继承的大多数好处，同时还能避免多重继承的复杂性和低效性；

    默认方法：
        可以为接口方法提供默认实现，以default修饰；
        默认方法可以调用其他方法；
        默认方法的一个重要用法是“接口演化”。为接口增加一个非默认方法不能保证“源代码兼容”；
        解决默认方法冲突：
            超类优先： 如果超类提供了一个具体方法，同名而且有相同参数类型的默认方法会被忽略；
            接口冲突： 如果一个接口提供了一个默认方法，另一个接口提供了一个同名而且参数类型相同的方法（不论是否是默认方法），必须覆盖这个方法来解决冲突；
            “类优先”规则可以确保与Java7的兼容性。如果为一个接口增加默认方法，这对于有默认方法之前能正常工作的代码不会有任何影响；
            由于“类优先”规则，不能创建一个默认方法重新定义Object类中的某个方法；

73、Comparable接口：
    Comparable接口的文档建议compareTo方法应当与equals方法兼容；
    有一个重要例外是BigDecimal， BigDecimal("1.0") 和 BigDecimal("1.00") equals返回false，compareTo返回0；
    如果两个对象不相等，返回哪个正值或者负值并不重要；
    语言标准规定：对于任意的x和y，实现者必须确保 sgn(x.compareTo(y)) = -sgn(y.compareTo(x)) ；
    这里的sgn是一个数的符号：如果n是负值，sgn(n)为-1；如果n等于0，sgn(n)为0，如果n是正值，sgn(n)为1。简单地讲，如果翻转compareTo的参数，结果的符号也应该翻转（但具体值不一定）；
    与equals方法一样，使用继承时有可能会出现问题，补救方式也一样，有两种不同的情况：
        如果不同子类中的比较有不同的含义，就应该将属于不同类的对象之间的比较视为非法；
        如果存在一个比较子类对象的通用算法，那么只需要在超类中提供一个compareTo方法，并将这个方法声明为final ；

74、回调（callback）是一种常见的程序设计模式。在这种模式中，可以指定某个特定事件发生时应该采取的动作。
75、Arrays.sort方法还有第二个版本，接受一个数组和一个比较器作为参数，比较器是实现了Comparator接口的类的实例。
76、如果原对象和浅克隆对象共享的子对象是不可变的，那么这种共享就是安全的。
77、Cloneable是一个标记接口，指示类设计者了解克隆过程。
    如果在一个对象上调用clone，但这个对象的类并没有实现Cloneable接口，就会抛出一个CloneNotSupportedException异常。
    克隆没有你想象中那么常用。标准库中只有不到5%的类实现了clone 。
    标记接口不包含任何方法，它唯一的作用就是允许在类型查询中使用instanceof。建议你自己的程序中不要使用标记接口。
78、克隆对象的另一种机制使用了Java的对象串行化特性。这个机制很容易实现，而且很安全，但效率不高。
79、所有数组类型都有一个公共的clone方法，而不是受保护的。可以用这个方法建立一个新数组，包含原数组所有元素的副本。
80、这就是Java的做法，它很认真地对待自己的承诺，不会为了方便而背弃承诺。
81、Comparator的nullsFirst和nullsLast适配器可以修改现有比较器，从而在遇到null值时不会抛出异常，而是将这个值标记为小于或大于正常值。
82、如果使用UNIX，并在命令行上提供内部类类名，要记住将 $ 字符进行转义。
83、获取包含静态方法的类名： new Object(){}.getClass().getEnclosingClass() //gets class of static method
84、利用ServiceLoader类可以很容易地加载符合一个公共接口的服务。
85、代理：
    利用代理可以在运行时创建实现了一组给定接口的新类；
    只有在编译时无法确定需要实现哪个接口时才有必要使用代理；
    对于编写应用程序的程序员来说，这种情况很少见；
    代理类是在程序运行过程中动态创建的。不过，一旦创建，它们就是常规的类，与虚拟机中的任何其他类没有什么区别；
    所有的代理类都扩展Proxy类；
    一个代理类只有一个实例字段——即调用处理器，它在Proxy超类中定义。完成代理对象任务所需要的任何额外数据都必须存储在调用处理器中；
    没有定义代理类的名字，Oracle虚拟机的Proxy类会生成以字符串$Proxy开头的类名；
    对于一个特定的类加载器和一组接口，只能有一个代理类。也就是说，如果使用同一个类加载器和接口数组调用两次newProxyInstance方法，将得到同一个类的两个对象；
    可以利用getProxyClass方法获得这个类；（@Deprecated since 9）
    代理类总是public和final；
    如果代理类实现的所有接口都是public，这个代理类就不属于任何特定的包；否则，所有非公共的接口都必须属于同一个包，而且代理类也属于这个包；
    可以用isProxyClass方法检测一个特定的Class对象是否表示一个代理类；
    调用一个目标代理的默认方法会触发调用处理器，要具体调用这个方法，可以使用InvocationHandler接口的静态方法invokeDefault；

86、栈轨迹（stack trace）是程序执行过程中某个特定点上所有挂起的方法调用的一个列表。
    可以使用 StackWalker类（JDK9） 方便地遍历栈轨迹。
87、断言机制允许你在测试期间在代码中插入一些检查，而在生产代码中自动删除这些检查。
    在一个具有自我保护能力的程序中，断言很常用；
    断言表达式部分的唯一目的是生成一个消息字符串；
    在默认情况下，断言是禁用的；
    可以使用 -ea(-enableassertions) / -da(-disableassertions) 选项 启用/禁用 断言；
    不必重新编译程序来启用或禁用断言，启用或禁用断言是类加载器的功能。禁用断言时，类加载器会去除断言代码，因此，不会降低程序运行的速度。
    可以在特定的类或整个包中 启用/禁用 断言；
    需要使用 -esa(-enablesystemassertions) 开关启用系统类中的断言；
88、使用断言的建议：
    断言失败是致命的、不可恢复的错误；
    断言检查只在开发和测试阶段打开；
89、断言方法参数被称为前置条件，如果调用者没有满足这个前置条件，断言会失败，这个方法就能“为所欲为”。
    事实上，由于有这个断言，当方法被非法调用时，它的行为将是难以预料的。
90、断言是一种用于测试和调试的战术性工具；与之不同，日志是一种用于程序整个生命周期的战略性工具。
91、使用日志API的优点：
    可以很容易地抑制全部日志记录，或者只抑制某个级别以下的日志，而且再次打开这些日志也很容易；
    被抑制的日志开销低廉，因此，将这些日志代码留在应用中只有很小的开销；
    日志记录可以定向到不同的处理器，如在控制台显示、写至文件等；
    日志记录器和处理器都可以对记录进行过滤。过滤器可以根据实现过滤器的程序员提供的标准丢弃那些无用的日志记录；
    日志记录可以采用不同的方式格式化，例如，纯文本或XML；
    应用程序可以使用多个日志记录器，它们使用与包名类似的有层次的名字；
    日志系统的配置由配置文件控制；
92、很多应用会使用其他日志框架，如Log4J2和Logback，它们能提供比标准Java日志框架更高的性能。这些框架的API稍有区别。SLF4J和Commons Logging等日志门面提供了一个统一的API，利用这个API，你无须重新应用就可以替换日志框架。
93、Java日志API的默认日志级别为INFO，如果想记录更低级别的日志，需要同时修改日志记录器和日志处理器的配置。
94、默认情况下，日志记录器将记录发送到ConsoleHandler，它会将记录输出到System.err流。具体地，日志记录器会把记录发送到父处理器，而最终的祖先处理器（名为“”）有一个ConsoleHandler 。
95、可以使用 -verbose 参数观察启动Java虚拟机时的类加载过程，这对诊断类路径问题很有帮助。
96、Java虚拟机提供了对Java应用的监控和管理支持，允许在虚拟机中安装代理来跟踪内存消耗、线程使用、类加载等情况。
    Java提供了 jconsole 和 jmc 工具来帮助进行性能分析和问题诊断。
97、Java的一个主要设计目标是支持与之前版本的向后兼容。因此，Java的泛型有一些让人不快的局限性。
98、得到编译错误要比运行时出现类的强制类型转换异常好的多。
99、应用程序员很可能不会编写太多的泛型代码。
100、JDK开发人员已经为所有的集合类提供了类型参数。
101、Java代码不能编写有相同参数类型的两个方法，但是，在虚拟机中，会由参数类型以及返回类型共同指定一个方法。
    因此，编译器可以为两个仅返回类型不同的方法生成字节码，虚拟机能够正确地处理这种情况。
    桥方法不只是用于泛型类型，还用于协变返回类型（覆盖方法时指定更严格的返回类型）。
102、@SafeVarargs只能用于声明为static、final或（Java9中）private的构造器和方法。所有其他方法都可能被覆盖，这会使这个注解失去意义。
103、CDI 和 Guice 等注入框架使用类型字面量来控制泛型类型的注入。
