1、串行回收：
    串行回收使用单线程进行垃圾回收，在回收的时候Mutator需要STW。新生代通常采用复制算法，老生代通常采用标记压缩算法。
2、并行回收：
    并行回收使用多线程进行垃圾回收，在回收的时候Mutator需要STW。新生代通常采用复制算法，老生代通常采用标记压缩算法。
3、并发标记回收（CMS）：
    并发标记回收的整个回收期间划分成多个阶段：初始标记、并发标记、重新标记、并发清除等。
    在初始标记和重新标记阶段需要暂停Mutator，在并发标记和并发清除期间可以和Mutator并发运行。
    这个算法通常适用于老生代，新生代可以采用并行回收。
4、垃圾优先回收（Garbage-First，也称为G1）：
    垃圾优先回收器将堆拆成一系列的分区，分区可在新生代和老生代之间进行切换。
    G1新生代的收集方式是并行收集，采用复制算法。
    G1会根据预测时间动态改变新生代的大小。
    G1在任意时刻只有一部分老生代分区会被回收，并且，这部分老生代分区将在下一次增量回收时与所有的新生代分区一起被收集。这就是我们所说的混合回收。在选择老生代分区的时候，优先考虑垃圾多的分区，这就是垃圾优先这个名字的由来。
    在G1中还有一个概念就是大对象，指的是待分配的对象大小超过一定的阈值之后，为了减少这种对象在垃圾回收过程的复制时间，直接把对象分配到老生代分区中而不是新生代分区中。
    从实现角度来看，G1算法是复合算法。
