# 学习 C++20

## 第 1 章  免费、流行的 C++ 编译器

1. 正如可互换零件的概念对于工业革命至关重要一样，可重用的类之于对象技术推动下的软件革命也至关重要。
2. 为了创建最好的解决方案，应遵循一个详细的分析过程来确定项目的需求（即定义系统应该做什么），并开发一个满足这些需求的设计（即决定系统应该如何做）。  
    理想情况下，在写任何代码之前，都应经历这个过程并仔细审查设计（同时让其他软件专业人士审查这个设计）。

## 第 2 章  C++ 编程入门

1. 以 // 开头的注释称为单行注释。用 `/* 和 */` 可创建多行注释。
2. 编译器在对程序进行编译之前会先调用预处理指令。  
    预处理指令（例如 #include）不是 C++ 语句，不以分号结束。
3. “空白”（包括空格、制表符和空行）编译时会直接被忽略。
4. C++ 程序通常由一个或多个函数和类组成。  
    每个程序必须有一个且只能有一个 main 函数，这是 C++ 程序开始执行代码的地方，称为程序的入口点。  
    如果程序执行到 main 的结束大括号时没有遇到 return 语句，C++ 会默认已经遇到 return 0; 并假定程序成功终止。
5. 所有变量声明都必须包含一个数据类型和一个名称。  
    大括号初始化是 C++11 引入的一个特性。  
    虽然并非一定要显式初始化每个变量，但这样做有助于防止多种多样的问题。  
    同一类型的变量可以一次性声明。
6. 标识符是由字母、数字和下划线（_）组成的一系列字符，不能以数字开头，也不能是语言的关键字。  
    C++ 区分大小写，同一个字母的大小写形式是两个不同的字符。  
    C++ 语言允许任何长度的标识符。  
    不要以下划线和一个大写字母开头，也不要以两个下划线开头，这种形式的标识符是 C++ 编译器内部使用的。  
    根据惯例，变量名标识符以小写字母开头，而且名称中第一个单词之后的每个单词都以大写字母开头。这种命名惯例称为驼峰式命名法。
7. 变量声明可以放到程序的几乎任何地方，但必须在变量使用前声明。
8. 在单个语句中使用多个 << 操作符，这称为对多个流插入操作进行连接。
9. 整数除法结果中的任何小数部分都被截断，不会有四舍五入。
10. 求余操作符 % 只能应用于整数操作数。
11. 两组圆括号没有嵌套，但处于“同一级”上，C++ 标准没有规定这些圆括号的子表达式的求值顺序。
12. 赋值操作符（=）从右到左分组。  
    表达式 x=y=0 等同于 x=(y=0) ，即从右到左，首先将0赋给y，再将y的求值结果（即0）赋给x 。
13. 字符串：  
    字符串变量默认初始化为空字符串（即 "" ） 。  
    字符串比较区分大小写。  
    两个字符串相加的操作称为字符串连接。
14. 默认情况下，在输出一个条件的值时，C++ 显示0代表假，1代表真。  
    `<iostream>` 头文件的流操纵元 boolalpha 告诉输出流将条件值显示为 false 或 true 。

## 第 3 章  控制语句（上）

1. 任何求值为零或非零的表达式都可以用作条件。  
    其中，零被视为假，而非零被视为真。
2. 空语句就是一个分号（;），它没有任何作用。
3. 条件操作符是 C++ 语言唯一的三元操作符。  
    条件操作符的优先级较低，所以一般将整个条件表达式放到圆括号中。
4. 执行算术运算时，编译器只知道如何求值所有操作数类型都一样的表达式。  
    编译器会对选定的操作数执行一种称为提升的操作，这也称为隐式转换。  
    在同时含有int和double数据类型的表达式中，C++将int操作数提升为double值。
5. 强制类型转换操作符可应用于所有基本类型和其他类型，只需在 static_cast 关键字后面的尖括号（<和>）中指定要转换成的类型即可。  
    它是一元操作符，只有一个操作数。  
    强制类型转换操作符的优先级是第二高的。
6. 使用参数化流操纵元的程序必须包含头文件 `<iomanip>` 。  
    setprecision 是一种参数化流操纵元，因其需要一个实参。  
    非参数化流操纵元 fixed 不需要实参，表示浮点值应该以定点格式输出。  
    定点格式强制浮点数在显示时不使用科学计数法。即使是整数，定点格式也能强制打印小数点和尾随的零。  
    流操纵元 setprecision 和 fixed 进行的是所谓的“粘性设置”，一旦指定，程序之后所有浮点值的格式都会应用这些设置，直至你再次改变它们。  
    使用流操纵元 setprecision 和 fixed 时，打印的值被四舍五入到当前精度所指定的小数位数。内存中的值保持不变。  
    如果不指定 setprecision 和 fixed ，C++ 语言默认保留4位小数。如果只指定 fixed ，C++ 保留6位小数。
7. 对于基本类型的变量，大括号初始化防止了可能会造成数据丢失的收缩转换。
8. 如果变量递增或递减自成一个语句，那么前缀和后缀版本的效果一样（无论递增还是递减）。  
    只有当变量用在一个更大的表达式中时，前缀版本和后缀版本才有不同的效果。
9. C++ 标准要求int类型至少为16位，long类型至少为32位，long long类型至少为64位。
10. 在 #include 指令中，和应用程序同一文件夹或某个子文件夹中的头文件通常被放在双引号（""）中，而不放在尖括号（<>）中。  
    双引号告诉编译器，这个头文件在当前应用程序所在的文件夹或者由你指定的另一个文件夹中。
11. C++14 引入了数字分隔符 ' （单引号字符）。
12. 字面值末尾加上 LL 可以指定 long long 类型的整数。
13. C++20 通过 format 函数引入了强大的、新的字符串格式化功能（需包含 `<format>` 头文件）。  
    format 函数默认从左到右替换其格式字符串实参中的占位符。
14. 开发任何一种算法都只需要三种类型的控制语句：顺序、选择和循环。

## 第 4 章  控制语句（下）

1. 由于浮点变量只能存储近似值，所以用浮点变量控制计数循环可能造成不精确的计数器值和不准确的终止测试，结果是造成循环无法正常终止。  
    有鉴于此，应当总是用整数变量控制计数循环。  
    如果想当然地以为浮点数表示的是准确的值（例如，在相等性比较中使用），就会导致错误的结果。
2. 如果必须在循环主体内部修改控制变量的值，最好使用while而不是for 。
3. 在所有 C++ 操作符中，逗号操作符的优先级最低。  
    逗号操作符表达式列表从左到右求值。  
    对于一个以逗号分隔的表达式列表，其值和类型分别是最右边的表达式的值和类型。
4. 对于需要精确货币计算和舍入控制的金融应用，可以考虑使用像 Boost.Multiprecision 这样的开源库。
5. setw 指定下个输出值应该占用的字符宽度的域。  
    如果输出的值需要的宽度少于指定字符，该值在域内默认右对齐。  
    如果输出的值需要的宽度超过指定字符，C++ 将域宽向右扩展以装下整个值。  
    如果不想采用默认的右对齐，而是想左对齐，可以输出一个非参数化的流操纵元 left（位于头文件 `<iostream>`）。  
    要恢复右对齐，输出一个非参数化的流操纵元 right 即可。
6. switch 语句的每个行动都和一个整数常量表达式的值关联。  
    任何字符和整数常量的组合，只要最终能求值为一个整数，都可以作为这种表达式使用。  
    default 标签可以放在 switch 主体的任何地方，但通常都放在最后。  
    switch 语句不需要为一个 case 的多个语句加上大括号，除非需要在一个 case 中声明变量。  
    在 switch 语句中，对控制表达式所有可能的值进行测试是一个好的做法。
7. 文件结束符（End-of-file indicator，EOF）是一个在不同系统上有所区别的组合键，用于指示没有更多数据可供输入。  
    Windows系统： Ctrl + z  
    类UNIX系统： Ctrl + d
8. 在需要的时候忘记 break 语句是一种逻辑错误。  
    为了提醒你注意这个可能的问题，许多编译器一旦发现 case 标签后面有一个或多个语句，但没有包含 break 语句，就会发出警告。  
    如果故意想要这种“直通”行为，C++17 专门引入了 [[fallthrough]] 特性。它告诉编译器，“直通”到下一个 case 是正确的行为。
9. 在“除以0”的情况下，整数除法会导致程序发生异常，而浮点除法得到的结果是 nan，代表 “not a number” （非数字）。
10. C++17 带初始化器的选择语句允许在 if 或 if...else 语句的条件之前以及 switch 语句的控制表达式之前包含变量初始化器。  
    初始化器必须以分号（;）结束。  
    在 if、if...else 或 switch 语句的初始化器中声明的任何变量都可以在语句的其余部分使用。
11. 在实现高质量的软件工程和实现最佳性能的软件之间存在着一种矛盾。  
    有时，这些目标中的一个是以牺牲另一个为代价的。  
    除非对性能有很高的要求，否则优先保证代码的简单和正确，再使它更快和更小——但只有在特别必要的时候。
12. 逻辑 AND 和逻辑 OR 表达式都是短路求值。
13. 当前的浮点数算术标准是 IEEE754 。

## 第 5 章  函数和函数模板入门

1. 为了促进可重用性，每个函数都应该执行单一的、良好定义的任务，而且函数名应该有效地表达这一任务。
2. 函数在使用之前必须定义或声明。  
    函数原型告诉编译器函数的名称、它的返回类型和参数类型，而且必须以一个分号（;）结束。  
    函数原型中的类型必须与函数定义头中的类型一致。参数名称通常与函数定义中的参数名称一致，但并不强求。  
    函数原型中的参数名称是可选的（不过编译器会忽略它们），但建议加上这些名称以便编写文档。  
    如果函数原型、函数定义头和函数调用在参数数量/类型/顺序以及函数的返回类型上不一致，就会发生编译错误。  
    如果函数调用中的实参不能被隐式转换为函数原型中指定的预期类型，就会发生编译错误。
3. C++ 标准并没有规定函数实参的求值顺序。  
    不同的编译器可以按照不同的顺序对传给函数的实参进行求值。
4. 函数的名称及其参数类型统称为函数签名。  
    函数的返回类型不是函数签名的一部分。  
    函数的作用域是程序中知道该函数的存在，并可访问该函数的区域。  
    同一作用域内的每个函数都必须有唯一的签名。
5. “C++ 核心准则”指出，使用 unsigned 类型并不能真正消除负值的可能性。
6. default_random_engine 生成的实际上是 伪随机数。  
    每次执行这些程序，这些序列实际上都会重复。  
    为了实现随机化，正确方式是使用 C++11 引入的 random_device 对象作为随机数生成器引擎的种子。
7. 枚举常量的基础值是int类型的，从 0 开始，默认情况下以 1 递增。  
    enum class 中的标识符必须是唯一的，但多个标识符可以有相同的（整数）值。  
    任何常量都可以在 enum class 定义中被显式赋予一个整数值。后续常量值总是比上一个大 1，直到被再次显示设置。  
    只能将枚举中声明的常量赋值给该类型的变量。  
    “C++ 核心准则”指出，enum class 中的常量应使用和变量相同的命名规则。  
    在遗留 C++ 代码中经常会看到全部大写的 enum 常量，这个实践目前已弃用。  
    用类型名称和 :: 来限定一个 enum class 类型的常量，会将该常量显式限定在该类型的作用域内。  
    “C++ 核心准则”建议始终使用 enum class 。  
    C++20 的 using enum 声明允许引用一个 enum class 的常量，而不必附加类型名称和作用域解析操作符（::）前缀。
8. 静态局部变量会在不同函数调用之间保留其值。
9. 在嵌套块中，如果外层块中的标识符与内层块中的标识符同名，那么外层块中的标识符将被“隐藏”，直到内层块结束。
10. 函数定义、放在函数外部的函数原型、类定义和全局变量均具有全局命名空间作用域。  
    全局变量是在所有类或函数定义的外部声明的。这种变量在程序执行期间会一直保留其值。
11. C++ 提供了内联函数来帮助减少函数调用开销。  
    在函数定义的返回类型前附加一个 inline 关键字，即可让编译器在调用该函数的每个地方都生成函数主体代码的一份拷贝（如果可以的话），从而避免函数调用。  
    编译器有可能忽略 inline 限定符。  
    可重用的内联函数通常放在头文件中，这样它们的定义就可以在使用了它们的每个源文件中内联。  
    更改了内联函数的定义后，必须重新编译调用该函数的所有代码。  
    虽然编译器可能自动内联你没有显式添加 inline 的代码，但“C++ 核心准则”指出，只应对“小的、对执行时间要求高”的函数进行内联。
12. 在许多编程语言中，向函数传递实参都采用两种方式：传值 和 传引用。  
    如果采用传值方式，会创建参数值的一个拷贝，并将该拷贝传给被调用的函数。对该拷贝的更改不会影响调用者的原始变量值。  
    传引用有利于性能，因其可以避免传值时对大量数据进行拷贝的开销。但是，传引用不利于安全性，因为被调用的函数可能破坏调用者的数据。  
    引用变量必须在声明时初始化，而且不能作为别名重新赋给其他变量。  
    所有对别名（即引用）进行的操作实际都是在原始变量上进行的。
13. 对未定义变量的引用称为空悬引用。  
    如果返回对局部非 static 变量的引用，该引用会指向（引用）一个在函数返回时被丢弃的变量。试图访问这样的变量会产生未定义的行为，往往会造成程序崩溃或数据破坏。
14. 默认参数必须是函数参数列表最右边（靠近尾部）的参数。  
    调用具有两个或多个默认参数的函数时，如果一个被省略的实参不是最右边的那个，该实参右边的所有实参也必须省略。  
    默认参数必须在函数名首次出现时指定，这通常是在函数原型中。  
    默认值可为任意表达式，包括常量、全局变量或其他函数调用。  
    默认参数也可与内联函数一起使用。
15. C++ 支持一元作用域解析操作符（即 ::） 。  
    如果使用了全局变量，一定要使用一元作用域解析操作符（::）来引用它（即使和局部变量的名称没有冲突）。  
    这使程序更容易修改，因为它减少了与非全局变量名称冲突的风险，并消除了局部变量将全局变量“隐藏”时可能发生的逻辑错误。
16. C++ 允许定义同名函数，只要它们有不同的签名即可，这称为函数重载。
17. 模板编程也称为泛型编程，定义单独一个函数模板，就相当于定义了全套重载函数。  
    C++会根据调用时提供的实参类型，自动生成单独的模板实例，以适当地处理每种类型的调用。
18. C++ 没有规定许多操作符的操作数求值顺序。因此，对这些调用的执行顺序不能做任何预设。
19. 任何能用递归方法解决的问题也能用循环方法解决。  
    如果递归方法能更自然地反映出问题，并导致程序更容易理解和调试，通常可以考虑递归方法。
