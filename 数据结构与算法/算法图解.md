# 算法图解

## 第 1 章  算法简介

1. 二分查找，也叫折半查找，是一种适用于顺序存储结构的查找方法。  
    表中的元素需按关键字大小有序排列。  
    时间复杂度为 O(logN)
2. 大 O 表示法指出了最糟情况下的运行时间。

## 第 2 章  选择排序

1. 数组是个重要的主题，一定要高度重视！
2. 选择排序（Simple Selection Sort）：时间复杂度为 O(N^2)  
　　在要排序的一组数中，选出最小（或者最大）的一个数与第1个位置的数交换；然后在剩下的数当中再找最小（或者最大）的与第2个位置的数交换，依次类推，直到第n-1个元素（倒数第二个数）和第n个元素（最后一个数）比较为止。

## 第 3 章  递归

1. 递归是很多算法都使用的一种编程方法。
2. 伪代码是对手头问题的简要描述，看着像代码，但其实更接近自然语言。
3. 递归只是让解决方案更清晰，并没有性能上的优势。  
    如果使用循环，程序的性能可能更高；如果使用递归，程序可能更容易理解。如何选择要看什么对你来说更重要。 —— Leigh Caldwell
4. 每个递归函数都有两部分：基线条件（base case）和递归条件（recursive case）。递归条件指的是函数调用自己，而基线条件则指的是函数不再调用自己。
5. 调用另一个函数时，当前函数暂停并处于未完成状态。该函数的所有变量的值都还在内存中。
6. 并非所有的语言都支持尾递归。
7. 小结：

    ```text
        * 递归指的是调用自己的函数。
        * 每个递归函数都有两个条件：基线条件和递归条件。
        * 栈有两种操作：压入和弹出。
        * 所有函数调用都进入调用栈。
        * 调用栈可能很长，这将占用大量的内存。
    ```

## 第 4 章  快速排序

1. 分而治之是一种著名的递归式、通用的问题解决方法。  
    分而治之（divide and conquer，D&C）并非可用于解决问题的算法，而是一种解决问题的思路。
2. 编写涉及数组的递归函数时，基线条件通常是数组为空或只包含一个元素。陷入困境时，请检查基线条件是不是这样的。
3. 归纳证明是一种证明算法行之有效的方式，它分两步：基线条件和归纳条件。
4. 快速排序是最快的排序算法之一，也是D&C典范。  
    快速排序的性能高度依赖于你选择的基准值。  
    假设你总是将第一个元素用作基准值，且要处理的数组是有序的，就会发生最糟情况。  
    快速排序的最佳情况也是平均情况。只要你每次都随机地选择一个数组元素作为基准值，快速排序的平均运行时间就将为 O(NlogN)  
    在最糟情况下，快速排序栈长为 O(N)，而在最佳情况下，栈长为 O(logN)  
    合并排序（merge sort）的运行时间总是 O(NlogN) ，快速排序在最糟情况下运行时间为 O(N^2)  
    有时候，常量的影响可能很大，对快速排序和合并排序来说就是如此。  
    快速排序的常量比合并排序小，因此如果它们的运行时间都为 O(NlogN) ，快速排序的速度将更快。  
    实际上，快速排序的速度确实更快，因为相对于遇上最糟情况，它遇上平均情况的可能性要大得多。

## 第 5 章  散列表

1. 散列表也被称为散列映射、映射、字典和关联数组。
2. 对于同样的输入，散列表必须返回同样的输出，这一点很重要。如果不是这样的，就无法找到你在散列表中添加的元素！
3. 处理冲突的方式很多，最简单的办法如下：如果两个键映射到了同一个位置，就在这个位置存储一个链表。
4. 散列函数很重要，好的散列函数很少导致冲突。
5. 在平均情况下，散列表的速度确实很快。  
    在最糟情况下，散列表所有操作的运行时间都为O(n)——线性时间，这真的很慢。
6. 在使用散列表时，避开最糟情况至关重要。为此，需要避免冲突。而要避免冲突，需要有：  
    较低的填装因子；  
    良好的散列函数。
7. 填装因子越低，发生冲突的可能性越小，散列表的性能越高。  
    一个不错的经验规则是：一旦填装因子大于0.7，就调整散列表的长度。

## 第 6 章  广度优先搜索

1. 解决最短路径问题的算法被称为广度优先搜索。  
    广度优先搜索是一种用于图的查找算法。  
    广度优先搜索的运行时间为 O(V + E)，其中V为顶点数，E为边数。
2. 图由节点（node）和边（edge）组成。
3. 小结：

    ```text
        * 广度优先搜索指出是否有从A到B的路径。
        * 如果有，广度优先搜索将找出最短路径。
        * 面临类似于寻找最短路径的问题时，可尝试使用图来建立模型，再使用广度优先搜索来解决问题。
        * 有向图中的边有箭头，箭头的方向指定了关系的方向。
        * 无向图中的边不带箭头，其中的关系是双向的。
        * 队列是先进先出（FIFO）的。
        * 栈是后进先出（LIFO）的。
        * 你需要按加入顺序检查搜索列表中的人，否则找到的就不是最短路径，因此搜索列表必须是队列。
        * 对于检查过的人，务必不要再去检查，否则可能导致无限循环。
    ```

## 第 7 章  狄克斯特拉算法

1. 带权重的图称为加权图（weighted graph），不带权重的图称为非加权图（unweighted graph）。
2. 狄克斯特拉算法的关键理念：找出图中最便宜的节点，并确保没有到该节点的更便宜的路径！  
    狄克斯特拉算法只适用于有向无环图（directed acyclic graph，DAG）
3. 如果有负权边，就不能使用狄克斯特拉算法。  
    这是因为狄克斯特拉算法这样假设：对于处理过的节点，没有前往该节点的更短路径。这种假设仅在没有负权边时才成立。因此，不能将狄克斯特拉算法用于包含负权边的图。  
    在包含负权边的图中，要找出最短路径，可使用另一种算法——贝尔曼·福德算法（Bellman-Ford algorithm）。
4. 小结：

    ```text
        * 广度优先搜索用于在非加权图中查找最短路径。
        * 狄克斯特拉算法用于在加权图中查找最短路径。
        * 仅当权重为正时狄克斯特拉算法才管用。
        * 如果图中包含负权边，请使用贝尔曼-福德算法。
    ```

## 第 8 章  贪婪算法

1. 贪婪算法很简单：每步都采取最优的做法。  
    用专业术语说，就是你每步都选择局部最优解，最终得到的就是全局最优解。  
    有时候，你只需找到一个能够大致解决问题的算法，此时贪婪算法正好可派上用场，因为它们实现起来很容易，得到的结果又与正确结果相当接近。
2. 在有些情况下，完美是优秀的敌人。  
3. 在获得精确解需要的时间太长时，可使用近似算法。判断近似算法优劣的标准如下：  
    速度有多快；  
    得到的近似解与最优解的接近程度。
4. 旅行商问题和集合覆盖问题有一些共同之处：你需要计算所有的解，并从中选出 最小/最短 的那个。这两个问题都属于NP完全问题。
5. 要判断问题是不是NP完全问题很难，易于解决的问题和NP完全问题的差别通常很小。NP完全问题通常具有以下特点：  
    元素较少时算法的运行速度非常快，但随着元素数量的增加，速度会变得非常慢。  
    涉及“所有组合”的问题通常是NP完全问题。  
    不能将问题分成小问题，必须考虑各种可能的情况。这可能是NP完全问题。  
    如果问题涉及序列（如旅行商问题中的城市序列）且难以解决，它可能就是NP完全问题。  
    如果问题涉及集合（如广播台集合）且难以解决，它可能就是NP完全问题。  
    如果问题可转换为集合覆盖问题或旅行商问题，那它肯定是NP完全问题。
6. 小结：

    ```text
        * 贪婪算法寻找局部最优解，企图以这种方式获得全局最优解。
        * 对于NP完全问题，还没有找到快速解决方案。
        * 面临NP完全问题时，最佳的做法是使用近似算法。
        * 贪婪算法易于实现、运行速度快，是不错的近似算法。
    ```

## 第 9 章  动态规划

1. 动态规划功能强大，它能够解决子问题并使用这些答案来解决大问题。  
    动态规划可帮助你在给定约束条件下找到最优解。  
    但仅当每个子问题都是离散的，即不依赖于其他子问题时，动态规划才管用。  
    在动态规划中，你要将某个指标最大化。
2. 小结：

    ```text
        * 需要在给定约束条件下优化某种指标时，动态规划很有用。
        * 问题可分解为离散子问题时，可使用动态规划来解决。
        * 每种动态规划解决方案都涉及网格。
        * 单元格中的值通常就是你要优化的值。
        * 每个单元格都是一个子问题，因此你需要考虑如何将问题分解为子问题。
        * 没有放之四海皆准的计算动态规划解决方案的公式。
    ```

## 第 10 章  K最近邻算法

1. 在实际工作中，经常使用余弦相似度（cosine similarity）。余弦相似度不计算两个矢量的距离，而比较它们的角度，因此更适合处理前面所说的情况。
2. 使用KNN时，挑选合适的特征进行比较至关重要。  
    在挑选合适的特征方面，没有放之四海皆准的法则，你必须考虑到各种需要考虑的因素。
3. 大多数机器学习算法都包含训练的步骤：要让计算机完成任务，必须先训练它。
4. 在根据以往的数据来预测未来方面，没有万无一失的方法。未来很难预测，由于涉及的变数太多，这几乎是不可能完成的任务。

## 第 11 章  接下来如何做

1. 在二叉查找树中查找节点时，平均运行时间为 O(log n)，但在最糟的情况下所需时间为 O(n)  
    而在有序数组中查找时，即便是在最糟情况下所需的时间也只有O(log n)，因此你可能认为有序数组比二叉查找树更佳。  
    然而，二叉查找树的插入和删除操作的速度要快得多。
2. B树是一种特殊的二叉树，数据库常用它来存储数据。
3. 绝妙、优雅且应用广泛的算法少之又少，傅里叶变换算是一个。
4. 对数组进行排序时，除非使用并行算法，否则运行时间不可能为O(n)！  
    对数组进行排序时，快速排序的并行版本所需的时间为O(n)
5. 分布式算法非常适合用于在短时间内完成海量工作，其中的MapReduce基于两个简单的理念：映射（map）函数和归并（reduce）函数。
6. 布隆过滤器是一种概率型数据结构，它提供的答案有可能不对，但很可能是正确的。  
    面临海量数据且只要求答案八九不离十时，可考虑使用概率型算法！
7. 线性规划用于在给定约束条件下最大限度地改善指定的指标。  
    线性规划是我知道的最酷的算法之一。  
    所有的图算法都可使用线性规划来实现。线性规划是一个宽泛得多的框架，图问题只是其中的一个子集。  
    线性规划使用Simplex算法。
