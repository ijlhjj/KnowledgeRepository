# 算法详解

## 算法基础

1. 算法设计中不存在万能的捷径，不存在适用于所有的计算问题的一种解决问题的方法。
2. 分治法的思路是把一个问题分解为几个更小的子问题，然后递归地解决这些子问题，并把它们的解决方案快速组合在一起形成原始问题的解决方案。  
    分治算法设计范式是一种通用的解决问题的方法，在许多不同的领域有着大量的应用。

### 第 1 章  绪论

1. 要想完成任何实质性的工作，理解算法的基础知识并掌握与算法密切相关的数据结构知识是必不可少的。
2. 成为优秀算法设计师的最重要原则就是拒绝满足。
3. Karatsuba 算法是 RecIntMult 算法的一种优化版本。  
    Karatsuba 算法只进行了3个递归调用，比 RecIntMult 算法少一个递归。
4. 主方法是一种功能强大且容易使用的工具，用于界定许多不同的分治方法的运行时间。
5. 随着递归深度的加深，递归调用的数量以指数级的速度增长。  
    我们必须记住一个事实，传递给每个递归调用的输入要明显小于上一级递归调用的输入。  
    这里存在两个相互制衡的竞争因素：一方面是需要解决的子问题的数量呈爆炸性增长；另一方面是这些子问题的输入越来越小。
6. 归并排序算法（Merge Sort）所执行的操作数量上界为 $6nlog_2n+6n$ 。

    ```text
        引人注目的是，特定的第 j 层所完成的工作居然与 j 无关！
            也就是说，递归树的每一层所执行的操作数是相同的（6n个操作）。
            这就为两个竞争因素提供了完美的平衡——子问题的数量在每一层都扩大一倍，但子问题所完成的工作量在每一层都减半。
        TimSort可以说是归并排序的终极优化版本，主要思想就是检测序列中的天然有序子段（若检测到严格降序子段则翻转序列为升序子段）。
            在最好情况下无论升序还是降序都可以使时间复杂度降至为O(n)，具有很强的自适应性。
    ```

7. 在一些高级编程语言中，一行代码的背后可能包含大量的基本操作。  
    例如，一行访问一个很长的数组的每个元素的代码所包含的基本操作的数量是与该数组的长度成正比的。
8. 最坏情况分析给出一个运行时间上界，即使遇到“最坏的”输入，这个上界仍然是有效的。  
    了解了问题的领域知识并理解哪些输入更具代表性之后，平均情况分析和基准实例分析都是非常实用的。  
    通用目的的子程序一般使用最坏情况来判断算法的性能。
9. 常数因子不可避免地依赖具体所使用的编程语言、特定的实现以及编译器和处理器的细节。  
    我们的目的是把注意力集中在那些与编程语言和计算机体系结构的细节无关的算法属性上，并且这些属性并不受到运行时间上界中的较小常数因子的变化的影响。  
    了解相关的常数因子也是非常有益的。例如，在许多程序库所提供的一个MergeSort高度优化的版本中，当输入数组的长度较小时（例如只有7个元素），它就从MergeSort切换为InsertionSort（因为它的常数因子更小）。
10. 事实上，计算机的速度越快，渐进性分析也就越重要。  
    计算目标总是随着计算能力的增长而不断扩大。  
    因此，随着时间的变迁，我们将会考虑越来越庞大的问题规模。  
    随着输入长度的增加，具有不同的渐进性运行时间的算法之间的性能差距只会变得更大。
11. 对于我们将要讨论的几乎所有问题，至高目标就是线性时间算法，即算法的运行时间与输入长度呈正比。  
    在任何情况下，它是我们可以企及的最高目标。
12. 算法分析的3个指导原则：  
    * 最坏情况分析，这是为了提高算法的通用性，不需要对输入预设条件；  
    * 全局分析，它通过忽略常数因子和低阶项实现预测能力和数学上的可实现性之间的平衡；  
    * 渐进性分析，它倾向于大量输入时的算法性能，这也是真正需要精妙算法的场合。
13. “无代价基本算法”是指算法具有线性或近线性运行时间，比读取输入所需要的时间多不了多少。
